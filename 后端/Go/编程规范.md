记法语法使用扩展巴克斯-诺尔范式（EBNF）定义：
生成式 = 生成式名 "=" [ 表达式 ] "." .
表达式 = 选择项 { "|" 选择项 } .
选择项 = 条目 { 条目 } .
条目   = 生成式名 | 标记 [ "…" 标记 ] | 组 | 可选项 | 重复项 .
组     = "(" 表达式 ")" .
可选项 = "[" 表达式 "]" .
重复项 = "{" 表达式 "}" .

生成式由表达式构造，表达式通过术语及以下操作符构造，自上而下优先级递增（低=>高）：
|   选择
()  分组
[]  可选 （0 或 1 次）
{}  重复 （0 到 n 次）

小写生成式名用于确定词法标记。非最终（Non-terminals）词法标记使用驼峰记法（CamelCase）。 置于双引号 "" 或反引号 `` 中的为词法标记。
形式 a … b 表示把从 a 到 b 的字符集作为选择项。 横向省略号 … 也在本文档的其它地方非正式地表示各种列举或简略的代码片断。 单个字符 …（不同于三个字符 ...）并非Go语言本身的标记。
源码的表示源码是采用UTF-8编码的Unicode文本。 该文本是非标准化的，因此单一的着重号码点不同于结合了字母与着重号的字符结构， 那些应当视为两个码点。为简单起见，本文档将使用未限定的术语字符在源文本中代替Unicode码点。
每个码点都是不同的，例如，大写与小写的字母就是不同的字符。
实现限制：为兼容其它工具，编译器会阻止字符NUL（U+0000）出现在源码文本中。
实现限制：为兼容其它工具，若UTF-8编码的字节序标记（U+FEFF）为源文本中的第一个Unicode码点， 编译器就会忽略它。
字符具体的Unicode字符类别由以下术语表示：
换行符      = /* Unicode码点 U+000A */ .
unicode字符 = /* 除newline以外的任意Unicode码点 */ .
unicode字母 = /* 类型为“字母”的Unicode码点 */ .
unicode数字 = /* 类型为“十进制数字”的Unicode码点 */ .

在Unicode标准6.2， 章节4.5 “一般类别” 中定义了字符集类别。 其中类别Lu，Ll，Lt，Lm及Lo被视为Unicode字母，类别Nd被视为Unicode数字。
字母和数字下划线字符_（U+005F）被视为一个字母。
字母         = unicode字母 | "_" .
十进制数字   = "0" … "9" .
八进制数字   = "0" … "7" .
十六进制数字 = "0" … "9" | "A" … "F" | "a" … "f" .

词法元素注释注释有两种形式：

	1. 行注释 以// 开始，至行尾结束。一条行注释视为一个换行符。
	2. 块注释 以 /* 开始，至 */ 结束。 块注释在包含多行时视为一个换行符，否则视为一个空格。

注释不可嵌套。
标记标记构成Go语言的词汇。它有4种类型：标识符，关键字， 运算符与分隔符以及字面。空白符由空格（U+0020）， 横向制表符（U+0009），回车符（U+000D）和换行符（U+000A）组成，除非用它来分隔会结合成单个的标记， 否则它将被忽略。此外，换行符或EOF（文件结束符）会触发分号的插入。 当把输入分解为标记时，可形成有效标记的最长字符序列将作为下一个标记。
分号正式语法使用分号 ";" 作为一些生成式的终止符。Go程序会使用以下两条规则来省略大多数分号：

	1. 当输入被分解成标记时，若该行的行末标记为以下标记之一，分号就会被自动插入到该标记流中的非空行末处：

		* 标识符
		* 整数， 浮点数， 虚数， 符文或 字符串 字面
		* 关键字 break， continue， fallthrough 或 return
		* 运算符与分隔符 ++， --， )， ]或 }

	2. 为允许复合语句占据单行，闭合的 ")" 或 "}" 之前的分号可以省略。

为符合习惯用法，本文档中的代码示例将使用这些规则省略分号。
标识符标识符被用来命名程序实体，例如变量和类型。一个标识符由一个或多个字母和数字组成。 标识符的第一个字符必须是字母。
标识符 = 字母 { 字母 | unicode数字 } .

a
_x9
ThisVariableIsExported
αβ

有些标识符是预声明的。
关键字以下为保留关键字，不能用作标识符。
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var

运算符与分隔符以下字符序列表示运算符，分隔符和其它特殊标记：
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
         &^          &^=

整数字面整数字面由数字序列组成，代表整数常量 。非十进制数由这些前缀定义： 0 为八进制数前缀，0x 或 0X为十六进制数前缀。 在十六进制数字面中，字母 a-f 或 A-F 表示值10到15。
整数字面       = 十进制数字面 | 八进制数字面 | 十六进制数字面 .
十进制数字面   = ( "1" … "9" ) { 十进制数字 } .
八进制数字面   = "0" { 八进制数字 } .
十六进制数字面 = "0" ( "x" | "X" ) 十六进制数字 { 十六进制数字 } .

42
0600
0xBadFace
170141183460469231731687303715884105727

浮点数字面浮点数字面由十进制浮点常量表示。 它由整数部分，小数点，小数部分和指数部分构成。整数部分与小数部分由十进制数字组成； 指数部分由一个 e 或 E 紧跟一个带可选正负号的十进制指数构成。 整数部分或小数部分可以省略；小数点或指数亦可省略。
浮点数字面 = 十进制数 "." [ 十进制数 ] [ 指数 ] |
                         十进制指数 |
                         "." 十进制数 [ 指数 ] .
十进制数   = 十进制数字 { 十进制数字 } .
指数       = ( "e" | "E" ) [ "+" | "-" ] 十进制数 .

0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5

虚数字面虚数字面由十进制复数常量的虚部表示。 它由浮点数字面或十进制整数紧跟小写字母 i 构成。
虚数字面 = (十进制数 | 浮点数字面) "i" .

0i
011i  // == 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i

符文字面符文字面由一个符文常量表示，一个整数值确定一个Unicode码点。 一个符文字面由围绕在单引号中的一个或更多字符表示。通常一个Unicode码点作为一个或更多字符围绕在单引号中。 在引号内，除单引号和换行符外的任何字符都可出现。引号内的单个字符通常代表该字符的Unicode值自身， 而以反斜杠开头的多字符序列则会编码为不同的形式。
最简单的形式就是引号内只有一个字符；由于Go源码文本是UTF-8编码的Unicode字符， 多个UTF-8编码的字节就可以表示一个单一的整数值。例如，字面 'a' 包含一个字节， 表示一个字面 a，Unicode字符U+0061，值 0x61，而 'ä' 则包含两个字节（0xc3 0xa4），表示一个字面 分音符-a， Unicode字符U+00E4，值 0xe4。
反斜杠转义允许用ASCII文本来编码任意值。将整数值表示为数字常量有4种方法： \x 紧跟2个十六进制数字；\u 紧跟4个十六进制数字； \U 紧跟8个十六进制数字；单个\紧跟3个八进制数字。 在任何情况下，字面的值都是其相应进制的数字表示的值。
尽管这些表示方式都会产生整数，其有效范围却不相同。八进制转义只能表示 0 到 255 之间的值。 十六进制转义则视其结构而定。转义符 \u 和 \U 表示Unicode码点， 因此其中的一些值是非法的，特别是那些大于 0x10FFFF 的值和半替代值。
在反斜杠后，某些单字符转义表示特殊值：
\a   U+0007 警报或铃声
\b   U+0008 退格
\f   U+000C 换页
\n   U+000A 换行
\r   U+000D 回车
\t   U+0009 横向制表
\v   U+000b 纵向制表
\\   U+005c 反斜杠
\'   U+0027 单引号(仅在符文字面中有效)
\"   U+0022 双引号(仅在字符串字面中有效)

在符文字面中，所有其它以反斜杠开始的序列都是非法的。
符文字面       = "'" ( unicode值 | 字节值 ) "'" .
unicode值      = unicode字符 | 小Unicode值 | 大Unicode值 | 转义字符 .
字节值         = 八进制字节值 | 十六进制字节值 .
八进制字节值   = `\` 八进制数字 八进制数字 八进制数字 .
十六进制字节值 = `\` "x" 十六进制数字 十六进制数字 .
小Unicode值    = `\` "u" 十六进制数字 十六进制数字 十六进制数字 十六进制数字 .
大Unicode值    = `\` "U" 十六进制数字 十六进制数字 十六进制数字 十六进制数字
                                                 十六进制数字 十六进制数字 十六进制数字 十六进制数字 .
转义字符       = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .

'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'aa'         // 非法：太多字符
'\xa'        // 非法：太少16进制数字
'\0'         // 非法：太少8进制数字
'\uDFFF'     // 非法：半代理值
'\U00110000' // 非法：无效Unicode码点

字符串字面字符串字面表示字符串常量，可通过连结字符序列获得。 它有两种形式：原始字符串字面和解译字符串字面。
原始字符串字面为反引号 `` 之间的字符序列。在该引号内， 除反引号外的任何字符都是合法的。原始字符串字面的值为此引号之间的无解译（隐式UTF-8编码的）字符组成的字符串； 另外，反斜杠没有特殊意义且字符串可包含换行符。原始字符串字面中的回车符将会从原始字符串的值中丢弃。
解译字符串字面为双引号 "" 之间的字符序列。 在该引号内，不包含换行符的文本形成字面的值，反斜杠转义序列如同在符文字面中一样以相同的限制被解译 （其中\'是非法的，而 \" 是合法的）。 3位八进制（\nnn）和2位十六进制（\xnn） 转义表示字符串值的独立 字节 ；其它转义符表示（可多字节）UTF-8编码的独立 字符。 因此在字符串字面中，\377 和 \xFF 表示值为 0xFF=255的单个字节， 而ÿ、\u00FF、\U000000FF 和 \xc3\xbf 则表示UTF-8编码的字符U+00FF的两个字节0xc3 0xbf。
字符串字面     = 原始字符串字面 | 解译字符串字面 .
原始字符串字面 = "`" { unicode字符 | 换行符 } "`" .
解译字符串字面 = `"` { unicode值 | 字节值 } `"` .

`abc`  // 等价于 "abc"
`\n
\n`    // 等价于 "\\n\n\\n"
"\n"
""
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"       // 非法：半代理值
"\U00110000"   // 非法：无效的Unicode码点

这些例子都表示相同的字符串：
"日本語"                                // UTF-8输入的文本
`日本語`                                // UTF-8输入的原始字面文本
"\u65e5\u672c\u8a9e"                    // 显式的Unicode码点
"\U000065e5\U0000672c\U00008a9e"        // 显式的Unicode码点
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 显式的UTF-8字节

如果源码将两个码点表示为一个字符，例如包含着重号和字母的结合形式， 那么将它放置在符文字面中就会产生一个错误（它不是单一码点），而放置在字符串字面中则会显示为两个码点。
常量常量包含布尔常量，符文常量， 整数常量，浮点数常量， 复数常量和字符串常量。 字符，整数，浮点数和复数常量统称为数值常量。
常量的值可由 符文， 整数， 浮点数， 虚数 或 字符串字面表示， 一个标识符可代表一个常量，一个常量表达式， 一个结果为常量的类型转换，或一些内建函数的返回值。 例如 unsafe.Sizeof 作用于任何值时产生的值， cap 或 len 作用于一些表达式时产生的值， real 和 imag 作用于复数常量时产生的值，以及 complex 作用于数值常量所产生的值。 布尔值由预声明的常量 true 和 false 来表示。 预声明标识符 iota 表示一个整数常量。
通常，复数常量的形式为 常量表达式，这一点将在该节中讨论。
数值常量可表示任意精度的值而不会溢出。
常量可以是类型化的或无类型化的。字面常量，true，false， iota 和某些只包含无类型化操作数的常量表达式是无类型化的。
常量可由常量声明或类型转换显式地赋予其类型， 也可由变量声明或赋值以及作为 表达式中的操作数隐式地赋予其类型。若常量的值不能由其类型表示就会产生一个错误。 例如，3.0 可赋予任何整数或浮点数类型的常量，而 2147483648.0 （等价于 1<<31）则只能赋予 float32, float64 或 uint32 类型的常量，而不能赋予 int32 或 string类型的常量。
Go语言中没有代表 IEEE-754 无穷大和 NaN 值（非数值）的常量，然而 math 包中的 Inf， NaN， IsInf 和 IsNaN 函数会在运行时返回并检验这些值。
实现限制：尽管数值常量在该语言中可拥有任意精度， 但编译器可能使用其有限精度的内部表示来实现它们。即，每个实现必须：

	* 使用至少256位表示整数常量。
	* 使用至少256位表示浮点常量，包括复数常量及尾数部分； 使用至少32位表示指数符号。
	* 若无法精确表示一个整数常量，则给出一个错误。
	* 若由于溢出而无法表示一个浮点或复数常量，则给出一个错误。
	* 若由于精度限制而无法表示一个浮点或复数常量，则舍入为最近似的可表示常量。

这些要求适用于字面常量和常量表达式的求值结果。
类型类型决定值的集合与该类型值特定的操作。类型可通过（或许为限定的） 类型名（§类型声明）或类型字面指定， 它将根据之前声明的类型组成新的类型。
类型     = 类型名 | 类型字面 | "(" 类型 ")" .
类型名   = 标识符 | 限定标识符 .
类型字面 = 数组类型 | 结构类型 | 指针类型 | 函数类型 | 接口类型 |
                   切片类型 | 映射类型 | 信道类型 .

布尔值，数值与字符串类型的实例的命名是预声明的。 数组，结构，指针，函数，接口，切片，映射和信道这些复合类型可由类型字面构造。
变量的静态类型（或类型）是通过其声明定义的类型。 接口类型的变量也有一个独特的动态类型，这是在运行时存储在变量中的值的实际类型。 动态类型在执行过程中可能会有所不同，但对于接口变量的静态类型，它总是可赋值的。 对于非接口类型，其动态类型始终为其静态类型。
每个类型 T 都有一个 基本类型：若 T 为预声明类型或类型字面， 其相应的基本类型为 T 本身。否则，T的基本类型为其 类型声明中所依据类型的基本类型。
   type T1 string
   type T2 T1
   type T3 []T1
   type T4 T3

以上 string，T1 和 T2 的基本类型为 string。 []T1，T3 和 T4 的基本类型为 []T1 。
方法集类型可拥有一个与其相关联的 方法集（§接口类型，§方法声明）。 接口类型的方法集为其接口。其它任意类型 T 的方法集由所有带接收者类型 T 的方法组成。与指针类型 *T 相应的方法集为所有带接收者 *T 或 T 的方法的集（就是说，它也包含 T 的方法集）。根据结构类型一节的描述， 更进一步的规则也适用于包含匿名字段的结构。任何其它类型都有一个空方法集。 在方法集中，每个方法都必须有唯一的方法名。
一个类型的方法集决定了其所实现的接口 与可使用该类型接收者调用的方法。
布尔类型布尔类型 表示由预声明常量 true 和 false所代表的布尔值的集。 预声明的布尔类型为 bool。
数值类型数值类型表示整数值和浮点数值的集。 架构中立的预声明数值类型为：
uint8       所有无符号 8位整数集（0 到 255）
uint16      所有无符号16位整数集（0 到 65535）
uint32      所有无符号32位整数集（0 到 4294967295）
uint64      所有无符号64位整数集（0 到 18446744073709551615）

int8        所有带符号 8位整数集（-128 到 127）
int16       所有带符号16位整数集（-32768 到 32767）
int32       所有带符号32位整数集（-2147483648 到 2147483647）
int64       所有带符号64位整数集（-9223372036854775808 到 9223372036854775807）

float32     所有IEEE-754 32位浮点数集
float64     所有IEEE-754 64位浮点数集

complex64   所有带float32实部和虚部的复数集
complex128  所有带float64实部和虚部的复数集

byte        uint8的别名
rune        int32的别名

n 位的整数值是 n 位宽的，它使用 二进制补码运算表示。
大小取决于具体实现的预声明数值类型：
uint     32或64位
int      大小与uint相同
uintptr  大到足以存储指针值无解释位的无符号整数

为避免可移植性问题，除 byte 为 uint8 的别名以及 rune 为 int32 的别名外，所有数值类型都是不同的。 当不同的数值类型混合在一个表达式或赋值操作中时，必须进行类型转换。 例如，int32 与 int 是不同的类型， 尽管它们在特定架构上可能有相同的大小。
字符串类型字符串类型 表示字符串值的集。字符串的值为（可能为空的）字节序列。字符串是不可变的： 一旦被创建，字符串的内容就不能更改。预声明的字符串类型为 string。
字符串 s 的长度（即其字节大小）可使用内建函数 len 获取。若该字符串为常量，则其长度即为编译时常量。 字符串的字节可通过整数（§下标）0 至 len(s)-1 访问。 获取这样一个元素的地址是非法的；若 s[i] 为字符串的第 i 个字节，&s[i] 就是无效的。
数组类型数组是单一类型元素的编号序列，该单一类型称为元素类型。元素的数量称为长度且为非负数。
数组类型 = "[" 数组长度 "]" 元素类型 .
数组长度 = 表达式 .
元素类型 = 类型 .

长度是数组类型的一部分，其求值结果必须可表示为 int 类型的非负常量。 数组 a 的长度可使用内建函数 len获取， 其元素可通过整数下标 0 到 len(a)-1 寻址。 数组类型总是一维的，但可组合构成多维的类型。
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // 等价于[2]([2]([2]float64))

切片类型切片是数组连续段的引用及包含此数组的元素的编号序列。 切片类型表示元素类型为数组的所有切片的集。未初始化切片的值为 nil。
切片类型 = "[" "]" 元素类型 .

类似于数组，切片是可索引的且拥有一个长度。切片 s 的长度可通过内建函数 len获取；不同于数组的是，切片可在执行过程中被改变， 其元素可通过整数（§下标） 0 到 len(s)-1寻址。 给定元素的切片下标可能小于它在其基本数组中的下标。
切片一旦初始化，就总是伴随着一个包含其元素的基本数组。 因此，切片与其数组及其它本数组的切片共享存储； 与此相反，不同的数组总是表示其不同的存储。
切片的基本数组可扩展其切片的结尾。容量 是该扩展的量度： 它是切片的长度和切片往后数组的长度之和；长度达到其容量的切片可通过从原切片 （§Slices）‘切下’一个新的来创建。 切片 a 的容量可使用内建函数 cap(a) 获取。
给定元素类型 T 的一个新的，已初始化的切片值使用内建函数 make创建， 它需要一个切片类型和指定其长度与可选容量的形参：
make([]T, length)
make([]T, length, capacity)

调用 make将分配一个被返回的切片值所引用的，新的、隐藏的数组。即，执行
make([]T, length, capacity)

产生切片与分配数组后再对其进行切片相同，因此这两个例子的结果为相同的切片：
make([]int, 50, 100)
new([100]int)[0:50]

类似于数组，切片总是一维的，但可组合构造更高维的对象。 元素为数组的数组，根据其构造，其内部数组的长度始终相同； 然而元素为切片的切片（或元素为数组的切片），其长度会动态地改变。 此外，其内部的切片必须单独地（通过 make）分配。
结构类型结构是已命名的元素序列，被称为字段，其中每一个元素都有一个名字和类型。 字段名可显示地指定（标识符列表）或隐式地指定（匿名字段）。 在结构中，非空白字段名必须是唯一的。
结构类型 = "struct" "{" { 字段声明 ";" } "}" .
字段声明 = (标识符列表 类型 | 匿名字段) [ 标注 ] .
匿名字段 = [ "*" ] 类型名 .
标注     = 字符串字面 .

// 空结构.
struct {}

// 带6个字段的结构
struct {
        x, y int
        u float32
        _ float32  // 填充
        A *[]int
        F func()
}

通过有类型而无显式字段名声明的字段为 匿名字段，亦称为 嵌入式 字段或该结构中此种类型的嵌入。 这种字段类型必须作为一个类型名 T 或一个非接口类型名的指针 *T来实现， 且 T 本身不能为指针类型。未限定类型名的行为类似于字段名。
// 带类型为T1，*T2，P.T3和*P.T4的4个匿名字段的结构
struct {
        T1        // 字段名为T1
        *T2       // 字段名为T2
        P.T3      // 字段名为T3
        *P.T4     // 字段名为T4
        x, y int  // 字段名为x和y
}

以下为非法声明，因为字段名在结构类型中必须是唯一的：
struct {
        T     // 与匿名字段*T及*P.T相冲突
        *T    // 与匿名字段T及*P.T相冲突
        *P.T  // 与匿名字段T及*T相冲突
}

在结构 x 中，若 x.f 为表示字段或方法 f 的合法选择者，则匿名字段的字段或方法 f 即为已提升的。
已提升字段除了不能用作该结构复合字面中的字段名外， 其行为如同结构的一般字段。
给定结构类型 S 与名为 T 的类型，包含在结构方法集中的已提升方法如下：

	* 若 S 包含一个匿名字段 T，则 S 与 *S 的方法集均包含带接收者 T 的已提升方法。*S 的方法集也包含带接收者 *T 的已提升方法。
	* 若 S 包含匿名字段 *T，则 S 与 *S 的方法集均包含带接收者 T 或 *T 的已提升方法。

字段声明可后跟一个可选的字符串字面 标注，成为所有相应字段声明中字段的属性。 标注可通过 反射接口 获得，否则就会被忽略。
// 一个对应于时间戳协议缓存的结构.
// 标注字符串定义了协议缓存的字段号.
struct {
        microsec  uint64 "field 1"
        serverIP6 uint64 "field 2"
        process   string "field 3"
}

指针类型指针类型表示一个所有给定类型变量的指针的集，称为指针的 基础类型。 未初始化的指针的值为 nil。
指针类型 = "*" 基础类型 .
基础类型 = 类型 .

*Point
*[4]int

函数类型函数类型表示所有带相同形参和返回类型的集。未初始化的函数类型变量的的值为 nil。
函数类型 = "func" 签名 .
签名     = 形参 [ 结果 ] .
结果     = 形参 | 类型 .
形参     = "(" [ 形参列表 [ "," ] ] ")" .
形参列表 = 形参声明 { "," 形参声明 } .
形参声明 = [ 标识符列表 ] [ "..." ] 类型 .

在形参或结果的列表中，其名称（标识符列表）必须都存在或都不存在。 若存在，则每个名称代表一个指定类型的项（形参或结果），所有在签名中的非 空白名称必须是唯一的。 若不存在，则每个类型代表一个此类型的项。若恰好有一个未命名的值，它可能写作一个不加括号的类型， 除此之外，形参和结果的列表总是在括号中。
函数签名中的最后一个形参可能有一个带 ... 前缀的类型。 带这样形参的函数被称为 变参函数 它可接受零个或多个实参的函数。
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)

接口类型接口类型指定一个称为 接口 的 方法集。 接口类型变量可存储任何带方法集类型的值，该方法集为此接口的超集。 这种类型表示 实现此接口。未初始化的接口类型变量的值为 nil。
接口类型   = "interface" "{" { 方法实现 ";" } "}" .
方法实现   = 方法名 签名 | 接口类型名 .
方法名     = 标识符 .
接口类型名 = 类型名 .

对于所有的方法集，在一个接口类型中，每个方法必须有唯一的名字。
// 一个简单的File接口
interface {
        Read(b Buffer) bool
        Write(b Buffer) bool
        Close()
}

不止一个类型可实现同一接口。例如，若两个类型 S1 和 S2 拥有方法集
func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }

（其中 T 代表 S1 或 S2） 那么 File 接口都将被 S1 和 S2所实现， 不论如何，方法 S1 和 S2 都会拥有或共享它。
类型可实现任何接口，包括任何其方法的子集，因此可能实现几个不同的接口。 例如，所有类型都实现了 空接口：
interface{}

同样，考虑此接口的实现，它出现在类型声明 中以定义一个名为 Lock 的接口：
type Lock interface {
        Lock()
        Unlock()
}

若 S1 和 S2 也实现
func (p T) Lock() { … }
func (p T) Unlock() { … }

它们不仅会实现 Lock 还会实现 File 接口
一个接口可通过包含一个名为 T 的接口类型来代替一个方法的实现。 这称之为嵌入接口，其效果等价于在接口中显式枚举出 T 中的方法。
type ReadWrite interface {
        Read(b Buffer) bool
        Write(b Buffer) bool
}

type File interface {
        ReadWrite  // 等价于枚举ReadWrite中的方法
        Lock       // 等价于枚举Lock中的方法
        Close()
}

接口类型 T 不能嵌入其自身或任何递归地嵌入 T 的接口类型。
// 非法：Bad不能嵌入其自身
type Bad interface {
        Bad
}

// 非法：Bad1不能通过Bad2嵌入其自身
type Bad1 interface {
        Bad2
}
type Bad2 interface {
        Bad1
}

映射类型映射是一个同种类型元素的无序组，该类型称为元素类型； 映射通过另一类型唯一的 键 集索引，该类型称为键类型。 未初始化的映射值为 nil。
映射类型    = "map" "[" 键类型 "]" 元素类型 .
键类型      = 类型 .

比较操作符 == 和 != （§比较操作符）必须由键类型的操作数完全定义； 因此键类型不能是函数，映射或切片。若该键类型为接口类型，这些比较运算符必须由动态键值定义； 失败将导致一个 运行时恐慌.
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}

元素的数量称为长度。 对于映射 m，其长度可使用内建函数 len 获取并可在执行时更改。元素可在执行时使用赋值来添加并通过 下标表达式 来检索；它们也可通过内建函数 delete删除。
一个新的，空的映射值使用内建函数 make 创建， 它使该映射类型和可选容量作为实参提示：
make(map[string]int)
make(map[string]int, 100)

初始容量不能限定它的大小：映射通过增长来适应存储在其中的项数，除了 nil 映射以外。 一个 nil 映射等价于一个空映射，只是 nil 映射不能添加元素。
信道类型信道提供一种机制使两个并发执行的函数同步执行，并通过传递具体元素类型的值来通信。 未初始化的信道值为 nil。
信道类型 = ( "chan" [ "<-" ] | "<-" "chan" ) 元素类型 .

<- 操作符指定信道的 方向，发送 或 接收。 若没有给定方向，那么该信道就是 双向的。 信道可通过类型转换 或 赋值被强制为只发送或只接收。
chan T          // 可以被用来发送和接收类型T的值
chan<- float64  // 只能被用来发送浮点数
<-chan int      // 只能被用来接收整数

<- 操作符结合最左边的 chan 可能的方式：
chan<- chan int    // 等价于 chan<- (chan int)
chan<- <-chan int  // 等价于 chan<- (<-chan int)
<-chan <-chan int  // 等价于 <-chan (<-chan int)
chan (<-chan int)

一个新的，已初始化的信道值可使用内建函数 make 创建， 它接受信道类型和一个可选的容量作为实参：
make(chan int, 100)

容量根据元素的数量设置信道中缓存的大小。若容量大于零，则信道是异步的： 若缓存未满（发送）或非空（接收），则通信操作无阻塞成功，且元素在发送序列中被接收。 若容量为零或无，则只有当发送者和接收者都做好准备时通信才会成功。 nil 信道永远不会准备好通信。
信道可通过内建函数close关闭； 接收操作符的多值赋值形式可测试信道是否关闭。
类型与值的性质类型标识两个类型若非 相同 即为 不同。
若两个已命名类型的类型名源自相同的类型实现，它们就是相同的。 一个已命名类型和一个未命名类型总不相同。若两个未命名类型其相应的类型字面相同， 那么它们的类型相同，即，它们的字面结构是否相同且其相应的组件类型是否相同。细节详述：

	* 若两个数组类型其元素类型相同且长度相同，那么它们的类型相同。
	* 若两个切片类型其元素类型相同，那么它们的类型相同。
	* 若两个结构类型其字段序列相同，相应字段名相同，类型相同，标注相同，那么它们的类型相同。 两个匿名字段其名字被认为相同。出自不同包的小写字段名总不相同。
	* 若两个指针类型其基础类型相同，那么它们的类型相同。
	* 若两个函数类型其形参个数相同，返回值相同，相应形参类型相同，返回值类型相同， 两函数都可变或都不可变，那么它们的类型相同。形参和返回值名无需匹配。
	* 若两个接口类型其方法集相同，名字相同，函数类型相同，那么它们的类型相同。 出自不同包的小写方法名总不相同。两接口类型是否相同与方法的次序无关。
	* 若两个映射类型其键值类型相同，那么它们的类型相同。
	* 若两个信道类型其值类型相同，方向相同，那么它们的类型相同。

给定声明
type (
        T0 []string
        T1 []string
        T2 struct{ a, b int }
        T3 struct{ a, c int }
        T4 func(int, float64) *T0
        T5 func(x int, y float64) *[]string
)

这些类型是相同的：
T0 和 T0
[]int 和 []int
struct{ a, b *T5 } 和 struct{ a, b *T5 }
func(x int, y float64) *[]string 和 func(int, float64) (result *[]string)

T0 和 T1 是不同的，因为它们由不同声明的类型命名； func(int, float64) *T0 和 func(x int, y float64) *[]string 是不同的， 因为 T0 不同于 []string。
可赋值性在下列情况下，值 x 可赋予 类型为 T 的变量 （"x 可赋予 T"）：

	* 当 x 的类型和 T 相同时。
	* 当 x 的类型 V 和 T 有相同的 基本类型 且在 V 或 T 中至少有一个不是已命名类型时。
	* 当 T 为接口类型且 x 实现了 T时。
	* 当 x 为双向信道值、T 为信道类型、 x 的类型 V 和 T 的元素类型相同且在 V 或 T 中至少有一个不是已命名类型时。
	* 当 x 为预声明标识符 nil 且 T 为指针、函数、切片、映射、通道或接口类型时。
	* 当 x 为无类型化，可通过类型 T 的值来表示的 常量时。

任何类型都可赋予空白标识符.
块块 为一对大括号括住的声明和语句。
块 = "{" { 语句 ";" } "}" .

除显式源码块外，还有隐式块：

	1. 全域块 包含所有的Go源码文本。
	2. 每个包都有包含其所有Go源码文本的 包块。
	3. 每个文件都有包含其所有Go源码文本的 文件块。
	4. 每个 if、for 和 switch 语句都被视为处于其自身的隐式块中。
	5. 每个 switch 或 select 语句中的子句其行为如同隐式块。

块可嵌套并会影响作用域。
声明与作用域声明可将非空白标识符绑定到一个常量、类型、变量、函数或包。 在程序中，每个标识符都必须被声明。同一标识符不能在同一块中声明两次，且在文件与包块中不能同时声明。
声明 = 常量声明 | 类型声明 | 变量声明 .
顶级声明 = 声明 | 函数声明 | 方法声明 .

已声明标识符的 作用域 即为该标识符所表示的具体常量、类型、变量、函数或包在源文本中的作用范围。
Go使用块表示词法作用域：

	1. 预声明标识符的作用域为全域块。
	2. 在顶级（即在任何函数之外）声明的表示常量、类型、变量或函数 （而非方法）的标识符其作用域为该包块。
	3. 已导入包的包名作用域为包含该导入声明的文件块。
	4. 表示方法接收器、函数形参或返回值变量的标识符，其作用域为该函数体。
	5. 在函数中声明为常量或变量的标识符，其作用域始于该函数中具体常量实现或变量实现 （ShortVarDecl表示短变量声明）的结尾，止于最内部包含块的结尾。
	6. 在函数中声明为类型的标识符，其作用域始于该函数中具体类型实现的标识符， 止于最内部包含块的结尾。

在块中声明的标识符可在其内部块中重新声明。 当其内部声明的标识符在作用域中时，即表示其实体在该内部声明中声明。
包子句并非声明；包名不会出现在任何作用域中。 其目的是为了识别该文件是否属于相同的包并为导入声明指定默认包名。
标签作用域标签通过标签语句声明，并用于 break、continue 和 goto 语句（§Break语句, §Continue语句, §Goto语句）。 定义不会使用的标签是非法的。与其它标识符相反，标签并不限定作用域且与非标签标识符并不冲突。 标签的作用域为除任何嵌套函数体外其声明的函数体。
空白标识符空白标识符 通过下划线字符 _ 表示， 它可像其它标识符一样用于声明，但该标识符不能传入一个新的绑定。
预声明标识符在全域块中，以下标识符是隐式声明的：
类型：
        bool byte complex64 complex128 error float32 float64
        int int8 int16 int32 int64 rune string
        uint uint8 uint16 uint32 uint64 uintptr

常量：
        true false iota

零值：
        nil

函数：
        append cap close complex copy delete imag len
        make new panic print println real recover

可导出标识符标识符可被 导出 以允许从另一个包访问。同时符合以下条件即为可导出标识符：

	1. 标识符名的第一个字符为Unicode大写字母（Unicode类别“Lu”）；且
	2. 该标识符在包块中已声明或为字段名或 方法名。

其它所有标识符均为未导出的。
标识符的唯一性给定一个标识符集，若其中一个标识符不同于该集中的任一标识符，那么它就是唯一的。 若两个标识符拼写不同，或它们出现在不同的包中且未 导出，那么它们就是不同的。否则，它们就是相同的。
常量声明常量声明将一个标识符（即常量名）列表绑定至一个常量表达式列表的值。 标识符的数量必须与表达式的数量相等，且左边第 n 个标识符会绑定至右边的第 n 个表达式的值。
常量声明   = "const" ( 常量实现 | "(" { 常量实现 ";" } ")" ) .
常量实现   = 标识符列表 [ [ 类型 ] "=" 表达式列表 ] .

标识符列表 = 标识符 { "," 标识符 } .
表达式列表 = 表达式 { "," 表达式 } .

若该类型存在，所有常量都将获得该类型实现，且该表达式对于该类型必须是 可赋值的。若该类型被省略，则该常量将获得其对应表达式的具体类型。 若该表达式值为无类型化常量，则其余已声明无类型化常量与该常量标识符表示其常量值。 例如，若该表达式为浮点数字面，则该常量标识符表示一个浮点数常量，即使该字面的小数部分为零。
const Pi float64 = 3.14159265358979323846
const zero = 0.0       // 无类型化浮点常量
const (
        size int64 = 1024
        eof        = -1    // 无类型化整数常量
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", 无类型化整数和字符串常量
const u, v float32 = 0, 3    // u = 0.0, v = 3.0

在 const 后括号中的声明列表，除第一句声明外，任何表达式列表都可省略。 若前面第一个非空表达式有类型，那么这样的空列表等价于该表达式原文和类型的代换。 因此，省略表达式的列表等价于重复前面的列表。其标识符的数量必须与上一个表达式的数量相等。 连同 iota 常量生成器，该机制允许轻量级连续值声明：
const (
        Sunday = iota
        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Partyday
        numberOfDays  // 该常量未导出
)

Iota在常量声明中预声明标识符 iota 表示连续的无类型化整数 常量。每当保留字 const 出现在源码中和每个 常量实现增量后，它都会被重置为0。它可被用来构造相关常量的集：
const (  // iota重置为0
        c0 = iota  // c0 == 0
        c1 = iota  // c1 == 1
        c2 = iota  // c2 == 2
)

const (
        a = 1 << iota  // a == 1 （iota已重置）
        b = 1 << iota  // b == 2
        c = 1 << iota  // c == 4
)

const (
        u         = iota * 42  // u == 0     （无类型化整数常量）
        v float64 = iota * 42  // v == 42.0  （float64常量）
        w         = iota * 42  // w == 84    （无类型化整数常量）
)

const x = iota  // x == 0 （iota已重置）
const y = iota  // y == 0 （iota已重置）

在表达式列表中，每个 iota 的值都相同，因为它只在每个常量实现后增量。
const (
        bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0
        bit1, mask1                           // bit1 == 2, mask1 == 1
        _, _                                  // 跳过 iota == 2
        bit3, mask3                           // bit3 == 8, mask3 == 7
)

最后一个例子采用上一个非空表达式列表的隐式副本。
类型声明类型声明将标识符、类型名 绑定至一个与现存类型有相同的 基本类型的新类型。新类型不同于现有类型。
类型声明     = "type" ( 类型实现 | "(" { 类型实现 ";" } ")" ) .
类型实现     = 标识符 类型 .

type IntArray [16]int

type (
        Point struct{ x, y float64 }
        Polar Point
)

type TreeNode struct {
        left, right *TreeNode
        value *Comparable
}

type Block interface {
        BlockSize() int
        Encrypt(src, dst []byte)
        Decrypt(src, dst []byte)
}

声明类型不继承任何方法绑定到现存类型， 但接口类型或复合类型元素的方法集保持不变：
// Mutex为带有Lock和Unlock两个方法的数据类型.
type Mutex struct         { /* Mutex字段 */ }
func (m *Mutex) Lock()    { /* Lock实现*/ }
func (m *Mutex) Unlock()  { /* Unlock实现*/ }

// NewMutex和Mutex拥有相同的组成，但它的方法集为空.
type NewMutex Mutex

// PtrMutex的基础类型的方法集保持不变.
// 但PtrMutex的方法集为空.
type PtrMutex *Mutex

// *PrintableMutex的方法集包含方法
// Lock和Unlock绑定至其匿名字段Mutex.
type PrintableMutex struct {
        Mutex
}

// MyBlock为与Block拥有相同方法集的接口类型.
type MyBlock Block

类型声明可用来定义不同的布尔值、数字或字符串类型并对其附上方法：
type TimeZone int

const (
        EST TimeZone = -(5 + iota)
        CST
        MST
        PST
)

func (tz TimeZone) String() string {
        return fmt.Sprintf("GMT+%dh", tz)
}

变量声明变量声明将一个标识符绑定至一个创建的变量并赋予其类型和可选的初始值。
变量声明     = "var" ( 变量实现 | "(" { 变量实现 ";" } ")" ) .
变量实现     = 标识符列表 ( 类型 [ "=" 表达式列表 ] | "=" 表达式列表 ) .

var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
        i       int
        u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // 映射检查；只与“found”有关

若给定一个表达式列表，则变量通过按顺序将该表达式赋予该变量（§赋值）来初始化； 所有表达式必须用尽且所有变量根据它们初始化。否则，每个变量初始化为其 零值。
若该类型已存在，每个变量都赋予该类型。否则，该类型根据该表达式列表赋值。
若该类型不存在且其对应表达式计算结果为无类型化常量， 则该声明变量的类型由其赋值描述。
实现限制：若在函数体内声明不会使用的变量，编译器可能将其判定为非法。
短变量声明短变量声明 使用此语法：
短变量声明 = 标识符列表 ":=" 表达式列表 .

它是有初始化表达式无类型化的常规变量声明的缩写：
"var" 标识符列表 = 表达式列表 .

i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() 返回两个值
_, y, _ := coord(p)  // coord() 返回三个值；只与和y同位的值相关

不同于常规变量声明，在至少有一个非空白变量时， 短变量声明可在相同块中，对原先声明的变量以相同的类型重声明。因此，重声明只能出现在多变量短声明中。 重声明不能生成新的变量；它只能赋予新的值给原来的变量。
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // 重声明 offset
a, a := 1, 2                              // 非法：重复声明了 a，或者若 a 在别处声明，但此处没有新的变量

短变量声明只能出现在函数内部。在某些情况下，例如初始化 if、 for、或 switch 语句时，它们可用来声明局部临时变量 （§语句）。
函数声明函数声明将标识符，即 函数名 绑定至函数。
函数声明 = "func" 函数名 签名 [ 函数体 ] .
函数名   = 标识符 .
函数体   = 块 .

函数声明可省略函数体。这样的标识符为Go外部实现的函数提供签名，例如汇编例程。
func min(x int, y int) int {
        if x < y {
                return x
        }
        return y
}

func flushICache(begin, end uintptr)  // 外部实现

方法声明方法为带 接收者 的函数。方法声明将标识符，即 方法名 绑定至方法。 它也将该接收者的 基础类型 关联至该方法。
方法声明   = "func" 接收者 方法名 签名 [ 函数体 ] .
接收者     = "(" [ 标识符 ] [ "*" ] 基础类型名 ")" .
基础类型名 = 标识符 .

接收者类型必须为形式 T 或 *T，其中 T 为类型名。 由 T 表示的类型称为接收者的 基础类型； 它不能为指针或接口类型且必须在同一包中声明为方法。 也就是说，该方法被 绑定 至基础类型且该方法名只对其内部此类型选择者可见。
非空白接收器的标识符在该方法签名中必须是唯一的。 若该接收器的值并未在该方法体中引用，其标识符可在声明中省略。这同样适用于一般函数或方法的形参。
对于基础类型，方法绑定至该类型的非空白名称必须唯一。 若其基础类型为结构类型，则非空白方法与字段名不能相同。
给定 Point 类型，声明
func (p *Point) Length() float64 {
        return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
        p.x *= factor
        p.y *= factor
}

将接收者类型为 *Point 的方法 Length 和 Scale 绑定至基础类型 Point。
方法的类型就是将接收者作为第一个实参的函数类型。例如，方法 Scale 拥有类型
func(p *Point, factor float64)

然而，通过这种方式声明的函数不是方法。
表达式表达式通过将运算符和函数应用至操作数来指定值的计算。
操作数操作数表示表达式中的基本值。操作数可为字面，（可能为限定的） 标识符可表示一个常量、变量或函数， 方法表达式可产生函数或者括号表达式。
操作数   = 字面 | 操作数名 | 方法表达式 | "(" 表达式 ")" .
字面     = 基本字面 | 复合字面 | 函数字面 .
基本字面 = 整数字面 | 浮点数字面 | 虚数字面 | 符文字面 | 字符串字面 .
操作数名 = 标识符 | 限定标识符.

限定标识符限定标识符为使用包名前缀限定的标识符。包名与标识符均不能为空白的。
限定标识符 = 包名 "." 标识符 .

限定标识符用于访问另一个包中的标识符，它必须被导入。 标识符必须是已导出且在该包的包块中声明。
math.Sin       // 表示math包中的Sin函数

复合字面复合字面每次为结构、数组、切片、映射构造值，或创建一个新值时，它们都会被求值。 它们由值的类型后跟一个大括号括住的列表组成。元素可为单个表达式或一个键-值对。
复合字面 = 字面类型 字面值 .
字面类型 = 结构类型 | 数组类型 | "[" "..." "]" 元素类型 |
                   切片类型 | 映射类型 | 类型名 .
字面值   = "{" [ 元素列表 [ "," ] ] "}" .
元素列表 = 元素 { "," 元素 } .
元素     = [ 键 ":" ] 值 .
键       = 字段名 | 元素索引 .
字段名   = 标识符 .
元素索引 = 表达式 .
值       = 表达式 | 字面值 .

字面类型必须为结构、数组、切片或映射类型（语法规则强制实施此约束，除非该类型作为类型名给定）。 表达式的类型对于其各自的字段、元素以及该字面类型的键类型必须为可赋值的， 即没有附加转换。作为结构字面的字段名，即数组和切片的下标以及映射字面的键，其键是可解译的。 对于映射字面，所有元素都必须有键。指定多个具有相同字段名或常量键值的元素会产生一个错误。
以下规则适用于结构字面：

	* 键必须为字面类型中声明的字段名。
	* 不包含任何键的元素列表必须按字段的声明顺序列出每个结构字段的元素。
	* 若其中任何一个元素有键，那么每个元素都必须有键。
	* 包含键的元素列表无需每个结构字段都有元素。被忽略的字段会获得零值
	* 字面可忽略元素列表；这样的字面对其类型求值为零值。
	* 为属于不同包的结构的未导出字段指定一个元素会产生一个错误。

给定声明
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }

可写为
origin := Point3D{}                            // Point3D 为零值
line := Line{origin, Point3D{y: -4, z: 12.3}}  // line.q.x 为零值

以下规则适用于数组和切片字面：

	* 在数组中每个元素都有与之对应的整数下标来标明它的位置。
	* 带键的元素使用该键作为它的下标；键必须为常量整数表达式。
	* 无键的元素使用上一个元素的下标加一。若第一个元素无键，则它的下标为零。

获取复合字面的地址（§地址操作符）就是为字面值的唯一实例生成一个指针。
var pointer *Point3D = &Point3D{y: 1000}

数组字面的长度为字面类型指定的长度。 若元素少于字面提供的长度，则缺失的元素会置为该数组元素类型的零值。 向超出数组下标范围的下标值提供元素会产生一个错误。 记法 ... 指定一个数组，其长度等于最大元素下标加一。
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2

切片字面描述全部的基本数组字面。因此，切片字面的长度和容量为其最大元素下标加一。切片字面具有形式
[]T{x1, x2, … xn}

它是切片操作应用到数组的捷径。
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]

在数组、切片或映射类型 T 的复合字面中，若其元素本身亦为复合字面， 且该复合字面的元素类型与 T 的相同，则可省略其各自的元素类型。 类似地，当元素类型为 *T 时，若其元素为复合字面的地址，则可省略 &T。
[...]Point{{1.5, -3.5}, {0, 0}}   // 等价于 [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}        // 等价于 [][]int{[]int{1, 2, 3}, []int{4, 5}}

[...]*Point{{1.5, -3.5}, {0, 0}}  // 等价于 [...]*Point{&Point{1.5, -3.5}, &Point{0, 0}}

当复合字面使用字面类型的类型名形式时，若它出现在关键字 "if"、"for" 或 "switch" 语句及其开大括号之间，就会产生解析歧义。因为在该字面中， 表达式外围的大括号会和那些语句块前的混淆。为解决此罕见情况中的歧义，该复合字面必须出现在小括号中。
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }

有效的数组、切片和映射字面的例子：
// 素数列表
primes := []int{2, 3, 5, 7, 9, 2147483647}

// 若 ch 为元音则 vowels[ch] 为 true
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// 数组 [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// 平均律以Hz为单位的频率（A4 = 440Hz）
noteFrequency := map[string]float32{
        "C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
        "G0": 24.50, "A0": 27.50, "B0": 30.87,
}

函数字面函数字面表示匿名函数。它由函数类型和函数体的规范组成。
函数字面 = 函数类型 函数体 .

func(a, b int, z float64) bool { return a*b < int(z) }

函数字面可赋予一个变量或直接调用。
f := func(x, y int) int { return x + y }
func(ch chan int) { ch <- ACK }(replyChan)

闭包 的函数字面：它们可引用定义在外围函数中的变量。 那些变量共享于外围函数与函数字面之间，并且只要它们可访问就会继续存在。
主表达式主表达式为一元和二元表达式的操作数。
主表达式 =
        操作数 |
        类型转换 |
        内建调用 |
        主表达式 选择者 |
        主表达式 下标 |
        主表达式 切片 |
        主表达式 类型断言 |
        主表达式 调用 .

选择者   = "." 标识符 .
下标     = "[" 表达式 "]" .
切片     = "[" [ 表达式 ] ":" [ 表达式 ] "]" .
类型断言 = "." "(" 类型 ")" .
调用     = "(" [ 实参列表 [ "," ] ] ")" .
实参列表 = 表达式列表 [ "..." ] .

x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()

选择者对于不为包名的主表达式 x， 选择其表达式
x.f

表示值 x（有时为 *x，见下）的字段或方法 f。 标识符 f 称为（字段或方法）选择者，它不能为空白标识符。 该选择者表达式的类型即为 f 的类型。若 x 为包名， 见限定标识符的相关章节。
选择者 f 可代表类型为 T 的字段或方法 f， 或引用 T 中嵌套匿名字段的字段或方法 f。 在 T 中遍历区域 f 的匿名字段所得的数量称为它的 深度。 以 T 声明的字段或方法 f 的深度为0。 在 T 中以匿名字段 A 声明的字段或方法 f 的深度 为 f 在 A 中的深度加1。
以下规则适用于选择者：

	1. 对于非接口类型 T 或 *T 的值 x， x.f 中的 f 表示在 T 中最浅深度的字段或方法。 若并非只有一个 f，该选择者表达式即为非法的。
	2. 对于接口类型 I 的变量 x，x.f 表示赋予 x 的值的名为 f 的真实方法。若在 I 的方法集中没有名为 f 的方法，该选择者即为非法的。
	3. 其它情况下，所有 x.f 均为非法的。
	4. 若 x 为指针或接口类型且值为 nil，对 x.f 进行赋值、求值或调用会产生 运行时恐慌.

选择者会自动解引用指向结构的指针。 若 x 为指向结构的指针，x.y 即为 (*x).y 的缩写； 若字段 y 亦为指向结构的指针，x.y.z 即为 (*(*x).y).z 的缩写, 以此类推。 若 x 包含类型为 *A 的匿名字段，且 A 亦为结构类型， x.f 即为 (*x.A).f 的缩写。
例如，给定声明：
type T0 struct {
        x int
}

func (recv *T0) M0()

type T1 struct {
        y int
}

func (recv T1) M1()

type T2 struct {
        z int
        T1
        *T0
}

func (recv *T2) M2()

var p *T2  // 其中 p != nil 且 p.T0 != nil

可以写：
p.z   // (*p).z
p.y   // ((*p).T1).y
p.x   // (*(*p).T0).x

p.M2()  // (*p).M2()
p.M1()  // ((*p).T1).M1()
p.M0()  // ((*p).T0).M0()

下标表达式形式为
a[x]

的主表达式表示数组、切片、字符串或映射 a 的元素通过 x 检索。 值 x 称为 下标 或 映射键。以下规则适用于其对应的类型：
若 a 并非一个映射：

	* 下标 x 必须为整数值；若 0 <= x < len(a) 则该下标在界内，否则即为越界
	* a 常量下标必须为可表示成 int 类型的值

对于数组类型 A 或 *A 的 a：

	* 常量下标必在界内
	* 若 a 为 nil 或 x 在运行时越界， 就会引发一个运行时恐慌
	* a[x] 是下标为 x 的数组元素，且 a[x] 的类型即为 A 的元素类型

对于切片类型 S 的 a：

	* 若该切片为 nil，或 x 在运行时越界， 就会引发一个运行时恐慌
	* a[x] 是下标为 x 的切片元素且 a[x] 的类型为 S 的元素类型

对于类型为字符串类型 T 的 a：

	* 若字符串 a 也为常量，常量下标必在界内。
	* 若 x 超出范围，就会出现一个运行时恐慌
	* a[x] 为下标 x 的字节且 a[x] 的类型为 byte
	* a[x] 不可赋值

对于类型为映射类型 M 的 a：

	* x 的类型必须可赋值至 M 的键类型
	* 若映射包含键为 x 的项，则 a[x] 为键 x 的映射值， 且 a[x] 的类型为 M 的值类型
	* 若映射为 nil 或不包含这样的项， a[x] 为 M 值类型的零值

否则 a[x] 即为非法的。
在类型为 map[K]V 的映射 a 中，下标表达式可使用特殊形式
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]

赋值或初始化，该下标表达式结果的类型为 (V, bool) 的值对。 在此形式中，若键 x 已在映射中，则 ok 的值为 true， 否则即为 false。v 的值为 a[x] 的单值形式。
向 nil 映射的元素赋值会引发运行时恐慌
切片对于字符串，数组，数组指针或切片 a，主表达式
a[low : high]

会构造一个字串或切片。下标 low 和 high 则选出哪些元素出现在结果中。 该结果的下标起始于 0 且长度等于 high - low。 在切下数组 a
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]

之后，切片 s 的类型为 []int，长度为 3，容量为 4，且元素
s[0] == 2
s[1] == 3
s[2] == 4

为方便起见，任何下标都可省略。略去的 low 下标默认为零； 略去的 high 下标默认为已切下的操作数的长度：
a[2:]  // 等价于 a[2 : len(a)]
a[:3]  // 等价于 a[0 : 3]
a[:]   // 等价于 a[0 : len(a)]

对于数组或字符串，若 0 <= low <= high <= len(a) 下标 low 和 high 即在界内，否则即在界外。 对于切片，其上界为该切片的容量 cap(a) 而非长度。常量下标必为非负值， 且可表示为 int 类型的值。若其下标也为常量，它们必定满足 low <= high。 若 a 为 nil 或其下标在运行时越界，就会引发一个运行时恐慌。
若已切下操作数为字符串或切片，该切片操作的结果即为相同类型的字符串或切片。 若已切下操作数为数组，它必须为可寻址的， 且该切片操作的结果为以相同元素类型作为数组的切片。
类型断言对于接口类型的表达式 x 与类型 T，主表达式
x.(T)

断言 x 不为 nil 且存储于 x 中的值其类型为 T。 记法 x.(T) 称为 类型断言。
更确切地说，若 T 为非接口类型，x.(T) 断言 x 的动态类型 与 T相同。在此情况下，T 必须实现 x 的（接口）类型，除非其类型断言由于无法为 x 存储类型为 T 的值而无效。若 T 为接口类型， x.(T) 则断言 x 的动态类型实现了接口 T。
若该类型断言成立，该表达式的值即为存储于 x 中的值，且其类型为 T。若该类型断言不成立， 就会出现一个运行时恐慌。换句话说，即使 x 的动态类型只能在运行时可知，在正确的程序中，x.(T) 的类型也可知为 T。
var x interface{} = 7  // x 拥有动态类型 int 与值 7
i := x.(int)           // i 拥有类型 int 与值 7

type I interface { m() }
var y I
s := y.(string)        // 非法：string 没有实现 I（缺少方法 m）
r := y.(io.Reader)     // r 拥有 类型 io.Reader 且 y 必须同时实现了 I 和 io.Reader

若类型断言以
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)

的形式用于赋值或初始化，该断言的结果即为类型为 (T, bool) 的值对。 若该断言成立，该表达式返回值对 (x.(T), true)；否则，该表达式返回 (Z, false)， 其中 Z 为类型为 T 的零值。此种情况不会产生运行时恐慌。 类型断言在这种构造中，其行为类似于函数调用返回一个值与一个布尔值以表示成功。
调用给定函数类型为 F 的表达式 f，
f(a1, a2, … an)

以实参 a1, a2, … an 调用 f。 除一种特殊情况外，实参必须为 可赋予 F 的形参类型的单值表达式，且在该函数被调用前求值。 该表达式的类型为 F 的返回类型。 方法调用也类似，只不过使用接收者类型值的选择者操作来指定方法。
math.Atan2(x, y)  // 函数调用
var pt *Point
pt.Scale(3.5)     // 带接收者 pt 的方法调用

在函数调用中，函数值与实参按一般顺序求值。 在它们求值后，该调用的形参传值至该函数，被调用函数开始执行。 当函数返回时，该函数的返回形参将值传回调用函数。
调用 nil 函数值会引发 运行时恐慌。
作为一种特殊情况，若函数或方法 g 的返回值在数量上等于函数或方法 f 的形参， 且分别可赋予它，那么调用 f(g(g的形参)) 将在依序绑定 g 的返回值至 f 的形参后引用 f。除 g 的调用外， f 的调用必须不包含任何形参。若 f 的最后有 ... 形参， 它在常规的形参赋值后，可被赋予 g 余下的返回值。
func Split(s string, pos int) (string, string) {
        return s[0:pos], s[pos:]
}

func Join(s, t string) string {
        return s + t
}

if Join(Split(value, len(value)/2)) != value {
        log.Panic("test fails")
}

若 x（的类型）的方法集包含 m， 且其实参列表可赋予 m 的形参列表，方法调用 x.m() 即为有效的。 若 x 为 可寻址的且 &x 的方法集包含 m， x.m() 即为 (&x).m() 的简写：
var p Point
p.Scale(3.5)

其中即没有明显的方法类型，也没有方法字面。
传递实参至...形参若 f 为最后带有形参类型 ...T 的可变参函数， 那么在该函数中，实参等价于类型为 []T 的形参。 对于每一个 f 的调用，传递至最后形参的实参为类型为 []T 的一个新切片， 其连续的元素即为实际的实参，它们必须都可赋予类型 T。 因此，该切片的长度为绑定至最后形参的实参的个数，且对于每一个调用位置可能都不同。
给定函数和调用
func Greeting(prefix string, who ...string)
Greeting("hello:", "Joe", "Anna", "Eileen")

在 Greeting 中，who 将拥有值 []string{"Joe", "Anna", "Eileen"}
若最后的实参可赋予类型为 []T 的切片且后跟着 ...， 它可能作为 ...T 形参的值不变而被传入。
给定切片 s 与调用
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)

在 Greeting 中，who 将作为与 s 一样的值拥有与其相同的基本数组。
操作符操作符与操作数结合成为表达式。
表达式     = 一元表达式 | 表达式 二元操作符 一元表达式 .
一元表达式 = 主表达式 | 一元操作符 一元表达式 .

二元操作符 = "||" | "&&" | 关系操作符 | 加法操作符 | 乘法操作符 .
关系操作符 = "==" | "!=" | "<" | "<=" | ">" | ">=" .
加法操作符 = "+" | "-" | "|" | "^" .
乘法操作符 = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

一元操作符 = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .

比较操作将在别处讨论。 对于其它二元操作符，操作数的类型必须相同， 除非该操作包含移位或无类型化常量。
除移位操作外，若其中一个操作数为无类型化常量而另一个不是， 该常量需类型转换为另一个操作数的类型。
移位表达式中的右操作数必须为无符号整数，或可转换为无符号整数的无类型化常量。 若非常量移位表达式的左操作数为无类型化常量，且该移位表达式已被其左操作数独自取代， 则该移位表达式的类型将变为该常量的类型；若其类型不能从上下文中判定 （例如，若该移位表达式在针对无类型化常量的比较操作中），则为 int类型。
var s uint = 33
var i = 1<<s           // 1 的类型为 int
var j int32 = 1<<s     // 1 的类型为 int32；j == 0
var k = uint64(1<<s)   // 1 的类型为 uint64；k == 1<<33
var m int = 1.0<<s     // 1.0 的类型为 int
var n = 1.0<<s != 0    // 1.0 的类型为 int；若int的大小为 32位，则 n == false
var o = 1<<s == 2<<s   // 1 与 2 的类型为 int；若 int 的大小为32位，则 o == true
var p = 1<<s == 1<<33  // 若 int 的大小为32位即为非法：虽然 1 的类型为 int，但 1<<33 溢出了 int
var u = 1.0<<s         // 非法: 1.0 的类型为 float64，不能移位
var v float32 = 1<<s   // 非法: 1 的类型为 float32，不能移位
var w int64 = 1.0<<33  // 1.0<<33 为常量移位表达式

操作符优先级一元操作符拥有最高优先级。 ++ 和 -- 操作符是语句，而非表达式，它们不属于运算符一级。 因此，语句 *p++ 等价于 (*p)++。
二元操作符有五种优先级。 乘法操作符结合性最强，其次为加法操作符、比较操作符、&&（逻辑与）， 最后为 ||（逻辑或）：
  优先级        操作符
        5             *  /  %  <<  >>  &  &^
        4             +  -  |  ^
        3             ==  !=  <  <=  >  >=
        2             &&
        1             ||

相同优先级的二元操作符从左到右结合。 例如，x / y * z 等价于 (x / y) * z。
+x
23 + 3*x[i]
x <= f()
^a >> b
f() || g()
x == y+1 && <-chanPtr > 0

算数操作符算数操作符适用于数值，并产生相同类型的结果作为第一个操作数。四个基本算数操作符 （+，-，*，/）适用于整数、浮点数和复数类型； + 也适用于字符串。其它所有算数操作符仅适用于整数。
+    和              integers, floats, complex values, strings
-    差              integers, floats, complex values
*    积              integers, floats, complex values
/    商              integers, floats, complex values
%    余              integers

&    按位与          integers
|    按位或          integers
^    按位异或        integers
&^   位清除（与非）  integers

<<   向左移位        integer << unsigned integer
>>   向右移位        integer >> unsigned integer

字符串可使用 + 操作符连结或 += 赋值操作符：
s := "hi" + string(c)
s += " and good bye"

字符串加法通过连结操作数创建一个新的字符串。
对于两个整数值 x 与 y，整数除法 q = x / y 和取余 r = x % y 满足以下关系：
x = q*y + r  且  |r| < |y|

将 x / y 向零截断（“除法截断”）。
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2

作为该规则的一个例外，若被除数 x 为 x 的int类型的最小负值，商 q = x / -1 等于 x（且 r = 0）。
                      x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808

若被除数为常量，则它必不为零。若被除数在运行时为零， 就会出现一个运行时恐慌。若被除数为非负数，且除数为2的常量次幂， 则该除法可被向右移位取代，且计算其余数可被按位“与”操作取代：
 x     x / 4     x % 4     x >> 2     x & 3
 11      2         3         2          3
-11     -2        -3        -3          1

移位操作符通过右操作数指定的移位计数来移位左操作数。若左操作数为带符号整数，它们就执行算术移位； 若左操作数为无符号整数，它们则执行逻辑移位。移位计数没有上界。 若左操作数移 n 位，其行为如同移 1 位 n 次。 按照其结果，x << 1 等价于 x*2，而 x >> 1 等价于 x/2 但向负无穷大截断。
对于整数操作数，一元操作符 +、- 和 ^ 的定义如下：
+x                  即为 0 + x
-x    相反数        即为 0 - x
^x    按位补码      即为 m ^ x  对于无符号的 x，m = "所有位置为1"
                                                                对于带符号的 x，m = -1

对于浮点数与复数来说，+x 等价于 x，而 -x 则为 x 的相反数。 浮点数或复数除以零的结果仅满足 IEEE-754 标准而无额外保证；是否会出现运行时恐慌取决于具体实现。
整数溢出对于无符号整数值，操作 +、-、* 和 << 均被计算为取模 2n，其中 n 为该无符号整数类型的位宽 （§数值类型）。不严格地说，这些无符号整数操作抛弃高位向上溢出，程序可依赖这种形式的“回卷”。
对于带符号整数，操作 +、-、* 和 << 可合法溢出， 而由此产生的值会继续存在，并由该带符号整数表现、操作、与其操作数决定性地定义。 除溢出外没有例外会导致此情况。在溢出不会发生的假定情况下编译器可能不会优化代码。 例如，我们无法假定 x < x + 1 总为真。
比较操作符比较操作符比较两个操作数并产生一个布尔值。
==    等于
!=    不等于
<     小于
<=    小于等于
>     大于
>=    大于等于

在任何比较中，第一个操作数必须为可赋予第二个操作数的类型，反之亦然。
相等性操作符 == 和 != 适用于可比较操作数。 顺序操作符 <、<=、> 和 >= 适用于有序的操作数。这些比较操作的关系和值定义如下：

	* 布尔值之间可比较。若两个布尔值同为 true 或同为 false，它们即为相等。
	* 通常情况下，整数值之间可比较或排序。
	* 根据 IEEE-754 标准的定义，浮点数值之间可比较或排序。
	* 复数值之间可比较。对于两个复数值 u 与 v， 若 real(u) == real(v) 且 imag(u) == imag(v)，它们即为相等。
	* 根据按字节词法，字符串值之间可比较或排序。
	* 指针值之间可比较。若两个指针指向相同的值或其值同为 nil，它们即为相等。 指向明显为零大小变量的指针可能相等也可能不相等。
	* 信道值可比较。若两个信道值通过相同的 make 调用 （§创建切片、映射和信道）创建或同为 nil 值，它们即为相等。
	* 接口值可比较。若两个接口值拥有相同的动态类型与相等的动态值，或同为 nil 值，它们即为相等。
	* 当非接口类型 X 的值可比较且 X 实现了 T 时， 非接口类型 X 的值 x 与接口类型 T 的值 t 则可比较。 若 t 的动态类型与 X 相同且 t 动态值等于 x，它们即为相等。
	* 若两个结构值的所有字段可比较，它们即可比较。若其相应的非空白字段相等，它们即为相等。
	* 若两个数组元素类型的值可比较，则数组值可比较。若其相应的元素相等，它们即为相等。

两个动态类型相同的接口值进行比较，若该动态类型的值不可比较，将引发一个运行时恐慌。 此行为不仅适用于直接的接口值比较，当比较接口值的数组或接口值作为字段的结构时也适用。
切片、映射和函数值同类型之间不可比较。然而，作为一种特殊情况，切片、映射或函数值可与预声明标识符 nil 进行比较。指针、信道和接口值与 nil 之间的比较也允许并遵循上面的一般规则。
比较的结果可赋予任何布尔类型。若上下文无需特殊的布尔类型，其结果的类型即为 bool。
type MyBool bool

var x, y int
var (
        b1 MyBool = x == y // 比较结果为类型 MyBool
        b2 bool   = x == y // 比较结果为类型 bool
        b3        = x == y // 比较结果为类型 bool
)

逻辑操作符逻辑操作符适用于布尔值并根据操作数产生一个相同类型的结果。右操作数有条件地求值。
&&    条件与    p && q  即  “若 p 成立则判断 q 否则返回 false”
||    条件或    p || q  即  “若 p 成立则返回 true 否则判断 q”
!     非        !p      即  “非 p”

地址操作符对于类型为 T 的操作数 x，地址操作符 &x 将生成一个类型为 *T 的指针指向 x。操作数必须可寻址，即，变量、间接指针、切片索引操作， 或可寻址结构操作数的字段选择者，或可寻址数组的数组索引操作均不可寻址。作为可寻址性需求的例外， x 也可为（可能带有括号的）复合字面.
对于指针类型为 *T 的操作数 x，间接指针 *x 表示类型为 T 的值指向 x。若 x 为 nil， 尝试求值 *x 将会引发运行时恐慌。
&x
&a[f(2)]
&Point{2, 3}
*p
*pf(x)

接收操作符对于信道类型的操作数 ch，接收操作符 <-ch 的值即为从信道 ch 接收的值。该信道的方向必须允许接收操作， 且该接收操作的类型即为该信道的元素类型。该值前的表达式块是有效的。 从 nil 信道接收将永远阻塞。从已关闭的信道接收将总是成功， 它会立刻返回其元素类型的零值
v1 := <-ch
v2 = <-ch
f(<-ch)
<-strobe  // 在时钟脉冲和丢弃接收值之前等待

接收表达式以
x, ok = <-ch
x, ok := <-ch
var x, ok = <-ch

的形式用于赋值或初始化将产生一个类型为 bool 的附加结果，来报告通信是否成功。 若接收的值由一次成功向信道发送的操作发出的，则 ok 的值为 true； 若接收的值是由于信道被关闭或为空而产生的零值，则为 false。
方法表达式若 M 在类型为 T 的方法集中， T.M 即为可调用函数，如同常规函数 带相同实参和 M 以该方法接收者的附加实参作为前缀 。
方法表达式 = 接收者类型 "." 方法名 .
接收者类型 = 类型名 | "(" "*" 类型名 ")" | "(" 接收者类型 ")" .

考虑一个类型为 T 的结构和两个方法， Mv，其接收者的类型为 T， Mp，其接收者的类型为 *T。
type T struct {
        a int
}
func (tv  T) Mv(a int) int         { return 0 }  // 值接收者
func (tp *T) Mp(f float32) float32 { return 1 }  // 指针接收者
var t T

表达式
T.Mv

将产生一个等价于 Mv 的方法，但它将一个显式的接收者作为其第一个实参；它拥有签名
func(tv T, a int) int

该函数可通过显式的接收者正常调用，因此以下五个调用是等价的：
t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)

同样，表达式
(*T).Mp

将产生一个带签名
func(tp *T, f float32) float32

的函数值来表示 Mp。 对于带值接收者的方法，它可以派生出一个带显式指针接收者的函数，因此
(*T).Mv

将产生一个带签名
func(tv *T, a int) int

的函数值来表示 Mv。这样的函数会通过接收者间接创建一个值作为该基本方法的接收者来传递； 该方法不会覆盖地址已经传入该函数调用的值。
最后一种情况，一个值接收者函数对于一个指针接收者方法是非法的， 因为指针接收者方法不在该值类型的方法集中。
从方法中派生出的函数值被函数调用语法调用。接收者作为第一个该调用的实参被提供。 也就是说，给定 f := T.Mv，f 将作为 f(t, 7) 而非 t.f(7) 被调用。要构造一个绑定了接收者的函数，需使用闭包。
从类型为接口的方法中派生出一个函数值是合法的。产生的函数将获得一个该接口类型的显式接收者。
类型转换类型转换是形式为 T(x) 的表达式，其中 T 为类型，而 x 是可转换为类型 T 的表达式。
类型转换 = 类型 "(" 表达式 [ "," ] ")" .

若类型以操作符 *、<- 或关键字 func 开始则必须加上括号：
*Point(p)        // 等价于 *(Point(p))
(*Point)(p)      // p 被转换为 (*Point)
<-chan int(c)    // 等价于 <-(chan int(c))
(<-chan int)(c)  // c 被转换为 (<-chan int)
func()(x)        // 函数签名 func() x
(func())(x)      // x 被转换为 (func())

常量值 x 在这些情况下可转换为类型 T：

	* x 可表示为类型为 T 的值。
	* x 为整数常量且 T 为 字符串类型。 有关非常量 x 的相同规则也适用于此种情况（§字符串类型的转换）。

转换一个常量将产生一个类型化的常量作为结果。
uint(iota)               // 类型为 uint 的 iota 值
float32(2.718281828)     // 类型为 float32 的 2.718281828
complex128(1)            // 类型为 complex128 的 1.0 + 0.0i
string('x')              // 类型为 string 的 "x"
string(0x266c)           // 类型为 string 的 "♬"
MyString("foo" + "bar")  // 类型为 MyString 的 "foobar"
string([]byte{'a'})      // 非常量：[]byte{'a'} 不为常量
(*int)(nil)              // 非常量：nil 不为常量，*int 不为布尔、 数值或字符串类型
int(1.2)                 // 非法：1.2 不能表示为 int
string(65.0)             // 非法：65.0 不为整数常量

非常量值 x 在这些情况下可转换为类型 T：

	* 当 x 可赋予 T时。
	* 当 x 的类型与 T 拥有相同的基本类型时。
	* 当 x 的类型与 T 为未命名指针类型，且它们的指针基础类型拥有相同的基本类型时。
	* 当 x 的类型与 T 同为整数或浮点数类型时。
	* 当 x 的类型与 T 同为复数类型时。
	* 当 x 为整数、字节切片或符文切片且 T 为字符串类型时。
	* 当 x 为字符串且 T 为字节切片或符文切片时。

具体规则应用于（非常量）与数值类型之间，或在字符串类型之间转换。 这些类型转换会改变 x 的表示并引发运行时的代价。 其它转换只改变类型而不改变 x 的表示。
======= >>>>>>> other <<<<<<< local没有语言机制能在指针和整数之间转换。包 unsafe 可在受限情况下实现此功能。
实现限制：为了与Go1语言规范向后兼容，编译器可在语法明确的转换中， 接受无括号的字面函数类型。
数值类型间的转换对于非常量数值类型的类型转换，以下规则适用：

	1. 当在整数类型间转换时，若该值为无符号整数，其符号将扩展为隐式无限精度，反之为零扩展。 然后截断以符合该返回类型的大小。例如，若 v := uint16(0x10F0)，则uint32(int8(v)) == 0xFFFFFFF0。类型转换总产生有效值，且无溢出指示。
	2. 当转换浮点数为整数时，小数部分将被丢弃（向零截断）。
	3. 当转换整数或浮点数为浮点类型，或转换复数类型为另一个复数类型时，其返回值将舍入至目标类型指定的精度。 例如，类型为 float32 的变量 x 的值可能使用超出 IEEE-754 标准32位数的额外精度来存储，但 float32(x) 表示将 x 的值舍入为32位精度的结果。 同样，x + 0.1 会使用超过32位的精度，但 float32(x + 0.1) 却不会。

在所有涉及非常量浮点数或复数值的类型转换中，若该返回类型不能表示该转换成功的值，则该返回值取决于具体实现。
字符串类型的转换
	1. 将有符号或无符号整数值转换为字符串类型将产生一个包含UTF-8表示的该整数的字符串。 有效Unicode码点范围之外的值将转换为 "\uFFFD"。

string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd "
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"


	2. 将字节切片转换为字符串类型将产生一个连续字节为该切片元素的字符串。 若该切片值为 nil，则其结果为空字符串。

string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"

type MyBytes []byte
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"


	3. 将符文切片转换为字符串类型将产生一个已转换为字符串的单个符文值的串联字符串。 若该切片值为 nil，则其结果为空字符串。

string([]rune{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"


	4. 将字符串类型值转换为字节类型切片将产生一个连续元素为该字符串字节的切片。 若该字符串为空，其结果为 []byte(nil)。

[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}


	5. 将字符串类型的值转换为符文类型切片将产生一个包含该字符串单个Unicode码点的切片。 若该字符串为空，其结果为 []rune(nil)。

[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}



常量表达式常量表达式可只包含常量操作数并在编译时求值。
无类型化布尔、数值和字符串常量可被用作操作数，无论使用布尔、数值或字符串类型的操作数是否合法。 除移位操作外，若二元操作的操作数是不同种类的无类型化常量，对于非布尔操作，该操作与其结果使用出现在此列表中较后的种类： 整数、符文、浮点数、复数。例如，由无类型化复数常量分离的无类型化整数常量将产生一个无类型化复数常量。
常量比较总是产生无类型化布尔常量。若常量移位表达式 的左操作数为无类型化常量，则该结果为整数常量；否则为与左操作数类型相同的常量，左操作数必须为整数类型 （§算术操作符）。将其它所有操作符应用于同种类（即，布尔、整数、浮点数、复数或字符串常量） 无类型化常量的结果：
const a = 2 + 3.0          // a == 5.0   （无类型化浮点数常量）
const b = 15 / 4           // b == 3     （无类型化整数常量）
const c = 15 / 4.0         // c == 3.75  （无类型化浮点数常量）
const Θ float64 = 3/2      // Θ == 1.0   (类型为float64，3/2 是整数除法)
const Π float64 = 3/2.     // Π == 1.5   (类型为float64，3/2. 是浮点数除法)
const d = 1 << 3.0         // d == 8     （无类型化整数常量）
const e = 1.0 << 3         // e == 8     （无类型化整数常量）
const f = int32(1) << 33   // f == 0     （类型为int32）
const g = float64(2) >> 1  // 非法       （float64(2)为无类型化浮点数常量）
const h = "foo" > "bar"    // h == true  （无类型化布尔常量）
const j = true             // j == true  （无类型化布尔常量）
const k = 'w' + 1          // k == 'x'   （无类型化符文常量）
const l = "hi"             // l == "hi"  （无类型化字符串常量）
const m = string(k)        // m == "x"   （类型为string）
const Σ = 1 - 0.707i       //            （无类型化复数常量）
const Δ = Σ + 2.0e-4       //            （无类型化复数常量）
const Φ = iota*1i - 1/1i   //            （无类型化复数常量）

将内建函数 complex 应用于无类型化整数、符文或浮点数常量将产生一个无类型化复数常量。
const ic = complex(0, c)   // ic == 3.75i （无类型化复数常量）
const iΘ = complex(0, Θ)   // iΘ == 1.5i  （类型为complex128）

常量表达式总是精确地求值；中间值与该常量本身可能需要明显大于该语言中任何预声明类型所支持的精度。以下为合法声明：
const Huge = 1 << 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)
const Four int8 = Huge >> 98  // Four == 4                                (type int8)

常量除法或求余的除数必不能为零：
3.14 / 0.0   // 非法：除以零

类型化常量的值必须总是可作为该常量类型的值被准确地表示。以下为非法常量表达式：
uint(-1)     // -1 无法表示为 uint
int(3.14)    // 3.14 无法表示为 int
int64(Huge)  // 1267650600228229401496703205376 无法表示为 int64
Four * 300   // 操作数 300 无法表示为 int8（Four 的类型）
Four * 100   // 其结果 400 无法表示为 int8（Four 的类型）

用于一元按位补码操作符 ^ 的屏蔽与非常量相匹配的规则：对于无符号常量屏蔽全为1， 而对于带符号或无类型化常量为-1。
^1         // 无类型化整数常量，等于-2
uint8(^1)  // 非法，等价于 uint8(-2)，-2无法表示为 uint8
^uint8(1)  // 类型化uint8常量，等价于0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // 等价于int8(-2)
^int8(1)   // 等价于-1 ^ int8(1) = -2

实现限制：在计算无类型化浮点数或复数常量表达式时，编译器可能使用舍入，参考章节常量 的实现限制。次舍入可能会导致浮点常量表达式在整数上下文中无效，即使在它使用无限精度计算时会成为整体。
求值顺序当对一个表达式、赋值或Return语句进行求值时， 所有函数调用、方法调用以及通信操作均按从左到右的词法顺序求值。
例如，在赋值
y[f()], ok = g(h(), i()+x[j()], <-c), k()

中，函数调用与通信按顺序 f()、h()、i()、j()、 <-c、g() 和 k() 发生。然而，相较于这些事件的顺序，x 的求值与索引及 y 的求值并未指定。
a := 1
f := func() int { a = 2; return 3 }
x := []int{a, f()}  // x可能为[1, 3]或[2, 3]：a与f()之间的求职顺序并未指定

单表达式中的浮点数操作根据该操作符的结合性求值。显式的圆括号通过覆盖默认结合性来影响求值。 在表达式 x + (y + z) 中，加法 y + z 会在与 x 相加前执行。
语句语句控制执行。
语句 =
        声明 | 标签语句 | 简单语句 |
        Go语句 | Return语句 | Break语句 | Continue语句 | Goto语句 |
        Fallthrough语句 | 块 | If语句 | Switch语句 | Select语句 | For语句 |
        Defer语句 .

简单语句 = 空语句 | 表达式语句 | 发送语句 | 递增递减语句 | 赋值 | 短变量声明 .

空语句空语句不执行任何操作。
空语句 = .

标签语句标签语句可作为 goto、break 或 continue 语句的目标
标签语句 = 标签 ":" 语句 .
标签     = 标识符 .

Error: log.Panic("error encountered")

表达式语句除特殊的内建函数外，函数与方法的调用及 接收操作均可出现在语句上下文中。这样的语句可能需要加小括号。
表达式语句 = 表达式 .

以下内建函数不允许出现在语句上下文中：
append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof

h(x+y)
f.Close()
<-ch
(<-ch)
len("foo")  // 若len为内建函数即为非法

发送语句发送语句在信道上发送值。信道表达式必须为信道类型， 信道的方向必须允许发送操作，且被发送的值的类型必须可赋予该信道的元素类型。
发送语句 = 信道 "<-" 表达式 .
信道     = 表达式 .

信道与值表达式均在通信开始前求值。通信会阻塞，直到发送可继续进行。 若接收者已就绪，在无缓存信道上发送可继续进行。 若缓存中有空间，在有缓存信道上发送可继续进行。 在已关闭信道上进行发送会引发一个运行时恐慌。 在 nil 信道上进行发送将永远阻塞。
ch <- 3

递增递减语句"++" 与 "--" 语句会以无类型化常量 1 来递增或递减它们的操作数。 就赋值来说，操作数必须为可寻址的，或为映射的下标表达式。
递增递减语句 = 表达式 ( "++" | "--" ) .

以下赋值语句在语义上等价：
递增递减语句        赋值
x++                 x += 1
x--                 x -= 1

赋值
赋值 = 表达式列表 赋值操作符 表达式列表 .

赋值操作符 = [ 加法操作符 | 乘法操作符 ] "=" .

每个左操作数必须为可寻址的、映射下标表达式或空白标识符。 操作数可加小括号。
x = 1
*p = f()
a[i] = 23
(k) = <-ch  // 等价于：k = <-ch

赋值操作 x op= y，其中 op 为一个二元算术操作符，它等价于 x = x op y，但只对 x 求值一次。 op= 为单个标记。在赋值操作中，左、右表达式列表必须均刚好包含一个单值表达式。
a[i] <<= 2
i &^= 1<<n

元组赋值将多值操作的个体元素赋予变量列表。它有两种形式。首先，右操作数为单个多值表达式，比如一个函数求值、 信道、映射操作或一个类型断言。 左操作数的数量必须与值的数量相匹配。例如，若 f 为返回两个值的函数，则
x, y = f()

会将第一个值赋予 x，而第二个值则会赋予 y。 空白标识符提供一种方式来忽略由多值表达式返回的值：
x, _ = f()  // 忽略由f()返回的第二值

在第二种形式中，左操作数的数量必须与右操作数的数量相等，其中的每一个必须为单值， 且右边第 n 个表达式会被赋予左边第 n 个表达式。此种赋值分两个阶段进行。
首先，左边的下标表达式与指针间接寻址的操作数 （包括选择者中隐式的指针间接寻址）和右边的表达式都会按通常顺序求值。 其次，赋值会按照从左到右的顺序进行。
a, b = b, a  // 交换a和b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // 置 i = 1，x[0] = 2

i = 0
x[i], i = 2, 1  // 置 x[0] = 2，i = 1

x[0], x[0] = 1, 2  // 置 x[0] = 1，然后置 x[0] = 2（因此最后x[0] == 2）

x[1], x[3] = 4, 5  // 置 x[1] = 4，然后恐慌置 x[3] = 5

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // 置 x[2] = 6，然后恐慌置 p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // 置 i, x[2] = 0, x[0]
        break
}
// 该循环结束之后，i == 0 且 x == []int{3, 5, 3}

在赋值中，每个值必须可赋予已赋值操作数的类型。若无类型化常量 已被赋予接口类型的变量，则该常量即被转换为类型 bool、rune、int、float64、complex128 或 string 之一，这取决于该值是否为布尔、符文、整数、浮点数、复数或字符串常量。
If语句"If"语句根据一个布尔表达式的值指定两个分支的条件来执行。 若该表达式求值为true，则执行"if"分支，否则执行"else"分支。
If语句 = "if" [ 简单语句 ";" ] 表达式 块 [ "else" ( If语句 | 块 ) ] .

if x > max {
        x = max
}

简单语句可能先于表达式，它将在表达式求值前执行。
if x := f(); x < y {
        return x
} else if x > z {
        return z
} else {
        return y
}

Switch语句"Switch"语句提供多路执行。表达式或类型说明符与"switch"中的"cases"相比较从而决定执行哪一分支。
Switch语句 = 表达式选择语句 | 类型选择语句 .

它有两种形式：表达式选择与类型选择。在表达式选择中，case包含的表达式针对switch表达式的值进行比较， 在类型选择中，case包含的类型针对特别注明的switch表达式的类型进行比较。
表达式选择在表达式选择中，switch表达式会被求值，而case表达式无需为常量，它按从上到下，从左到右的顺序求值； 第一个等于switch表达式的case表达式将引发相应情况的语句的执行；其它的情况将被跳过。 若没有情况匹配且有"default"情况，则该语句将被执行。 最多只能有一个默认情况且它可以出现在"switch"语句的任何地方。 缺失的switch表达式等价于表达式 true。
表达时选择语句 = "switch" [ 简单语句 ";" ] [ 表达式 ] "{" { 表达式情况子句 } "}" .
表达式情况子句 = 表达式选择情况 ":" { 语句 ";" } .
表达式选择情况 = "case" 表达式列表 | "default" .

在case或default子句中，最后一个语句可能只为"fallthrough"语句 （§Fallthrough语句）， 它表明该控制流应从该子句的结尾转至下一个子句的第一个语句。 否则，控制流转至该"switch"语句的结尾。
简单语句可能先于表达式，它将在表达式求值前执行。
switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // 缺失的switch表达式意为"true"
case x < 0: return -x
default: return x
}

switch {
case x < y: f1()
case x < z: f2()
case x == 4: f3()
}

类型选择类型选择比较类型而非值。它与表达式选择并不相似。它被一个特殊的switch表达式标记， 该表达式为使用保留字 type 而非实际类型的类型断言的形式：
switch x.(type) {
// cases
}

此时的case针对表达式 x 的动态类型匹配实际的类型 T。 就像类型断言一样，x 必须为接口类型， 而每一个在case中列出的非接口类型 T 必须实现了 x 的类型。
类型选择语句 = "switch" [ 简单语句 ";" ] 类型选择监视 "{" { 类型情况子句 } "}" .
类型选择监视 = [ 标识符 ":=" ] 主表达式 "." "(" "type" ")" .
类型情况子句 = 类型选择情况 ":" { 语句 ";" } .
类型选择情况 = "case" 类型列表 | "default" .
类型列表     = 类型 { "," 类型 } .

类型选择监视可包含一个短变量声明。 当使用此形式时，变量会在每个子句的隐式块的起始处声明。 在case列表刚好只有一个类型的子句中，该变量即拥有此类型；否则，该变量拥有在类型选择监视中表达式的类型。
case中的类型可为 nil（§预声明标识符）， 这种情况在类型选择监视中的表达式为 nil 接口值时使用。
给定类型为 interface{} 的表达式 x，以下类型选择：
switch i := x.(type) {
case nil:
        printString("x is nil")                // i 的类型为 x 的类型（interface{}）
case int:
        printInt(i)                            // i 的类型为 int
case float64:
        printFloat64(i)                        // i 的类型为 float64
case func(int) float64:
        printFunction(i)                       // i 的类型为 func(int) float64
case bool, string:
        printString("type is bool or string")  // i 的类型为 x 的类型（interface{}）
default:
        printString("don't know the type")     // i 的类型为 x 的类型（interface{}）
}

可被重写为：
v := x  // x 只被求值一次
if v == nil {
        i := v                                 // i 的类型为 x 的类型（interface{}）
        printString("x is nil")
} else if i, isInt := v.(int); isInt {
        printInt(i)                            // i 的类型为 int
} else if i, isFloat64 := v.(float64); isFloat64 {
        printFloat64(i)                        // i 的类型为 float64
} else if i, isFunc := v.(func(int) float64); isFunc {
        printFunction(i)                       // i 的类型为 func(int) float64
} else {
        _, isBool := v.(bool)
        _, isString := v.(string)
        if isBool || isString {
                i := v                         // i 的类型为 x 的类型（interface{}）
                printString("type is bool or string")
        } else {
                i := v                         // i 的类型为 x 的类型（interface{}）
                printString("don't know the type")
        }
}

简单语句可能先于类型选择监视，它将在类型选择监视求值前执行。
"fallthrough"语句在类型选择中不被允许。
For语句"for"语句指定块的重复执行。迭代通过条件、"for"子句或"range"子句控制。
For语句 = "for" [ 条件 | For子句 | Range子句 ] 块 .
条件 = 表达式 .

在最简单的形式中，只要布尔条件求值为真，"for"语句指定的块就重复执行。 条件会在每次迭代前求值。若缺少条件，则它等价于 true。
for a < b {
        a *= 2
}

带For子句的"for"语句也通过其条件控制，此外，它也可指定一个初始化或步进语句， 例如一个赋值、一个递增或递减语句。初始化语句可为一个短变量声明， 而步进语句则不能。
For子句    = [ 初始化语句 ] ";" [ 条件 ] ";" [ 步进语句 ] .
初始化语句 = 简单语句 .
步进语句   = 简单语句 .

for i := 0; i < 10; i++ {
        f(i)
}

若初始化语句非空，则只在第一次迭代的条件求值前执行一次。 步进语句会在块的每一次执行（且仅当块被执行）后执行。 任何For子句的元素都可为空，但除非只有一个条件，否则分号是必须的。 若缺少条件，则它等价于 true。
for cond { S() }    等价于    for ; cond ; { S() }
for      { S() }    等价于    for true     { S() }

带"range"子句的"for"语句通过遍历数组、切片、字符串或映射的所有项，以及从信道上接收的值来迭代。 对于每一项，它将迭代值赋予其相应的迭代变量，然后执行该块。
Range子句 = ( 表达式列表 "=" | 标识符列表 ":=" ) "range" 表达式 .

"range"子句右边的表达式称为range表达式，它可以是一个允许接受操作 的数组、数组指针、切片、字符串、映射或信道。就赋值来说，左边的操作数必须为 可寻址的或映射下标表达式；它们表示迭代变量。若range表达式为信道， 则只允有一个迭代变量，否则可为一个或两个。在后一种情况下，若第二个迭代变量为 空白标识符，则range子句等价于只存在第一个变量的相同子句。
除非range表达式为数组，否则它只会在开始循环前求值一次。在此情况下，它是否会被求值取决于该表达式（见下）。 左边的函数调用会在每次迭代时求值一次。对于每一次迭代，迭代值按照以下方式产生：
Range表达式                           第一个值            第二个值（若第二个变量存在）

数组或切片  a  [n]E、*[n]E 或 []E     下标  i  int        a[i]   E
字符串      s  string type            下标  i  int        见下   rune
映射        m  map[K]V                键    k  K          m[k]   V
信道        c  chan E, <-chan E    元素  e  E


	1. 对于数组、数组指针或切片值 a，下标迭代值按照递增顺序产生，从元素下标0开始。 作为一种特殊情况，若只存在第一个迭代变量，则range循环提供从0到 len(a) 的迭代变量而非索引该数组或切片自身。对于 nil 切片，迭代次数为0。
	2. 对于字符串值，"range"子句从字节下标0开始，遍历该字符串中的Unicode码点。在连续迭代中， 其下标值为该字符串中连续UTF-8编码码点第一个字节的下标。而类型为 rune的第二个值为则其相应码点的值。若该迭代遇到无效的UTF-8序列，则第二个值将为Unicode占位字符 0xFFD，且下一次迭代将推进至此字符串中的单个字节。
	3. 映射的遍历顺序并不确定且从某一次迭代到下一次并不保证相同。若在迭代过程中移除的映射项尚未受到影响， 则相应的迭代值不会产生。若在迭代过程中创建映射项，则该项可能会在迭代中产生或被跳过。 这种选择可能会改变已经创建的每一个项，并从一次迭代进入到下一次迭代中。 若该映射为 nil，则迭代的次数为0.
	4. 对于信道，其迭代值产生为在该信道上发送的连续值，直到该信道被关闭。若该信道为 nil，则range表达式将永远阻塞。

迭代值在赋值语句中将分别赋予其各自的迭代变量。
迭代变量可通过"range"子句使用短变量声明形式（:=）来声明。 在这种情况下，它们的类型将置为其各自的迭代值，且它们的作用域 终止于"for"语句的结尾，它们将在每次迭代时被重用。若迭代变量在"for"语句之外声明，则在每次执行后， 它们的值为最后一次迭代的值。
var testdata *struct {
        a *[7]int
}
for i, _ := range testdata.a {
        // testdata.a永不会被求值，len(testdata.a)为常量
        // i从0延伸到6
        f(i)
}

var a [10]string
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for i, s := range a {
        // i的类型为int
        // s的类型为string
        // s == a[i]
        g(i, s)
}

var key string
var val interface {}  // m值的类型可赋予val
for key, val = range m {
        h(key, val)
}
// key == 在迭代中遇到的最后一个映射键
// val == map[key]

var ch chan Work = producer()
for w := range ch {
        doWork(w)
}

Go语句"go"语句将函数调用的执行作为控制独立的并发线程或相同地址空间中的Go程来启动。
Go语句 = "go" 表达式 .

在调用Go程中，函数值与形参按照惯例求值， 但不像一般的调用，程序的执行并不等待已被调用的函数完成。取而代之，该函数在一个新的Go程中独立执行。 当该函数终止后，其Go程也将终止。若该函数拥有任何返回值，它们将在该函数完成后被丢弃。
go Server()
go func(ch chan<- bool) { for { sleep(10); ch <- true; }} (c)

Select语句"select"语句选择可能发生通信的集。它看起来与"switch"语句类似，但其case为所有涉及到通信的操作。
Select语句 = "select" "{" { 通信子句 } "}" .
通信子句   = 通信情况 ":" { 语句 ";" } .
通信情况   = "case" ( 发送语句 | 接收语句 ) | "default" .
接收语句   = [ 表达式列表 [ "," 标识符列表 ] ( "=" | ":=" ) ] 接收表达式 .
接收表达式 = 表达式 .

接收表达式必须为接收操作。对于"select"语句中的所有case， 信道表达式连同任何出现在发送语句右侧的表达式均按照从上到下的顺序求值。信道可能为 nil， 它等价于select语句中不存在该case，若是一个发送操作，其表达式仍将被求值。 若有任何由此产生的操作可以进行，则选择其中之一，且相应的通信和语句将被求值。否则，若有默认case， 则执行；若没有默认case，则该语句将阻塞直到其中一个通信完成。默认case最多只能出现一次， 且它可以出现在 "select" 语句中的任何地方。若没有非 nil 信道的case， 该语句将永远阻塞。即使该语句阻塞，当进入select语句时，信道与发送表达式也只会被求值一次。
在所有信道与发送表达式求值后，对于所有"select"语句中的通信，任何在此求值中的副作用都将发生。
若有多个case均可进行，则会构造一个均匀的伪随机数选择，以此决定哪一个通信将会执行。
接收case可使用短变量声明来声明一个或两个新的变量。
var c, c1, c2, c3 chan int
var i1, i2 int
select {
case i1 = <-c1:
        print("received ", i1, " from c1\n")
case c2 <- i2:
        print("sent ", i2, " to c2\n")
case i3, ok := (<-c3):  // 等价于 i3, ok := <-c3
        if ok {
                print("received ", i3, " from c3\n")
        } else {
                print("c3 is closed\n")
        }
default:
        print("no communication\n")
}

for {  // 向c发送位的随机序列
        select {
        case c <- 0:  // 注意：没有语句，没有fallthrough，也没有case折叠
        case c <- 1:
        }
}

select {}  // 永远阻塞

Return语句函数 F 中的“return”语句终止 F 的执行，并可选地提供一个或多个返回值。 任何被 F 推迟的函数会在 F 返回给其调用者前执行。
Return语句 = "return" [ 表达式列表 ] .

在没有返回类型的函数中，"return"语句不能指定任何返回值。
func noResult() {
        return
}

从具有返回类型的函数返回值的三种方式：

	1. 返回值可在"return"语句中显式地列出。每个表达式必须为单值， 且可赋予相应的函数返回类型的元素。

func simpleF() int {
        return 2
}

func complexF1() (re float64, im float64) {
        return -7.0, -4.0
}


	2. "return"语句中的表达式列表可为多值函数的单个调用。 其效果相当于将该函数返回的每一个值赋予同类型的临时变量， 并在"return"语句后面列出这些变量，在这点上与前面的情况规则相同。

func complexF2() (re float64, im float64) {
        return complexF1()
}


	3. 若函数的返回类型为其返回形参指定了名字（§函数类型）， 则表达式列表可为空。返回形参的行为如同一般的局部变量，且必要时该函数可向他们赋值。 "return"语句返回这些变量的值。

func complexF3() (re float64, im float64) {
        re = 7.0
        im = 4.0
        return
}

func (devnull) Write(p []byte) (n int, _ error) {
        n = len(p)
        return
}



无论它们如何声明，在进入该函数时，所有的返回值都会被初始化为该类型的零值（§零值）。 指定了结果的“return”语句会在任何被推迟的函数执行前设置结果形参。
Break语句"break"语句终止最内层的"for"、"switch"或"select"语句的执行。
Break语句 = "break" [ 标签 ] .

若存在标签，则它必须为闭合的"for"、"switch"或"select"语句，而此执行就会终止。 （§For语句, §Switch语句, §Select语句）。
L:
        for i < n {
                switch i {
                case 5:
                        break L
                }
        }

Continue语句"continue"语句在最内层"for"循环的步进语句处开始下一次迭代（§For语句）。
Continue语句 = "continue" [ 标签 ] .

若存在标签，则它必须为闭合的"for"语句，而此执行就会前进。（§For语句）。
Goto语句"goto"语句用于将控制转移到与其标签相应的语句。
Goto语句 = "goto" 标签 .

goto Error

执行"goto"不能在跳转点处产生任何还未在作用域中的变量来使其进入作用域。 比如，例子：
  goto L  // 这样不好
        v := 3
L:

是错误的，因为跳转至标签 L 处将跳过 v 的创建。
在块外的"goto"语句不能跳转至该块中的标签。 比如，例子：
if n%2 == 1 {
        goto L1
}
for n > 0 {
        f()
        n--
L1:
        f()
        n--
}

是错误的，因为标签 L1 在"for"语句的块中而 goto 则不在。
Fallthrough语句"fallthrough"语句将控制转移到表达式"switch"语句（§表达式选择） 中下一个case子句的第一个语句。它可能只被用作表达式"switch"语句中case或default子句里最后的非空语句。
Fallthrough语句 = "fallthrough" .

Defer语句"defer"语句调用的函数将被推迟到其外围函数返回时执行，不论是因为该外围函数执行了 return 语句，到达了其函数体的末尾， 还是因为其对应的Go程进入了恐慌过程。
Defer语句 = "defer" 表达式 .

该表达必须为一个函数或方法调用，它不能被括号括住。内建函数调用被限制为表达式语句。
"defer"语句每执行一次，它所调用的函数值与形参就会 像平时一样求值并重新保存，但实际的函数提并不会被执行。 取而代之的是，在外围的函数返回前，被推迟的函数会按照它们被推迟的相反顺序立即执行。
例如，若被推迟的函数为函数字面，而其外围函数在其作用域中的函数字面内拥有 已命名结果形参，则被推迟的函数可在该结果形参被返回前访问并更改。 若被推迟函数拥有任何返回值，则它们会在该函数完成时丢弃。 （另请参阅恐慌处理）一节。
lock(l)
defer unlock(l)  // 解锁在外围函数返回前发生

// 在外围函数返回前打印 3 2 1 0
for i := 0; i <= 3; i++ {
        defer fmt.Print(i)
}

// f 返回 1
func f() (result int) {
        defer func() {
                result++
        }()
        return 0
}

内建函数内建函数是预声明的。它们可以像其他任何函数一样被调用， 但其中某些函数则接受类型而非表达式来作为第一个实参。
内建函数并没有标准的Go类型，因此它们只能出现在调用表达式中，而不能作为函数值被使用。
内建调用 = 标识符 "(" [ 内建实参 [ "," ] ] ")" .
内建实参 = 类型 [ "," 实参列表 ] | 实参列表 .

关闭对于一个信道 c，内建函数 close(c) 标明不再有值会在该信道上发送。 若 c 为只接收信道，则会产生一个错误。向已关闭的信道发送信息或再次关闭它将引发 运行时恐慌。关闭 nil信道也会引发运行时恐慌。 在调用 close 之后，任何以前发送的值都会被接收，接收操作将无阻塞地返回该信道类型的零值。 多值 接收操作 会随着一个该信道是否关闭的指示返回一个已接收的值。
长度与容量内建函数 len 与 cap 接受各种类型的实参并返回 int 类型的结果。 该实现保证其结果总符合 int 类型。
调用      实参类型         结果

len(s)    string type      字符串的字节长度。
                  [n]T, *[n]T      数组长度（== n）
                  []T              切片长度
                  map[K]T          映射长度（已定义键的数量）
                  chan T           信道缓存中元素队列的长度

cap(s)    [n]T, *[n]T      数组长度（== n）
                  []T              切片容量
                  chan T           信道缓存容量

切片的容量为其基本数组中已分配的空间元素的数量。以下关系在任何时候都成立：
0 <= len(s) <= cap(s)

nil 切片、映射或信道的长度为0。nil 切片和信道的容量为0。
若 s 为字符串常量，则表达式 len(s) 即为 常量。 若 s 的类型为数组或数组指针，且表达式 s 不包含信道接收 或函数调用，则表达式 len(s) 与 cap(s) 即为常量，在这种用情况下， s不会被求值。否则，len 与 cap 的调用不为常量，且 s 会被求值。
分配内建函数 new 接受类型 T 并返回类型为 *T 的值。 其内存根据初始值（§零值）片段的描述来初始化。
new(T)

例如
type S struct { a int; b float64 }
new(S)

将为类型为 S 的变量动态分配内存、初始化（a=0，b=0.0）并返回类型为 *S 的包含内存地址的值。
创建切片、映射与信道切片、映射与信道为无需使用 new 来间接额外分配的引用类型。内建函数 make 接受的类型 T 必须为切片、映射或信道类型，可选地跟着一个特殊类型的表达式列表。它返回类型为 T（而非 *T）的值。其内存根据初始值（§零值）片段的描述来初始化。
调用             类型 T     结果

make(T, n)       slice      类型为T，长度为n，容量为n的切片
make(T, n, m)    slice      类型为T，长度为n，容量为m的切片

make(T)          map        类型为T的映射
make(T, n)       map        类型为T，初始空间为n个元素的映射

make(T)          channel    类型为T的同步信道
make(T, n)       channel    类型为T，缓存大小为n的异步信道

用于指定大小的实参 n 与 m 必须为整数值。 常量大小的实参必须为非负值，且可表示为 int 类型的值。 若 n 和 m 已给定且为常量，则 n 必不大于 m。若 n 在运行时为负值或大于 m， 就会引发运行时恐慌。
s := make([]int, 10, 100)       // len(s) == 10，cap(s) == 100 的切片
s := make([]int, 1e3)           // len(s) == cap(s) == 1000 的切片
s := make([]int, 1<<63)         // 非法：len(s) 不能表示为 int 类型的值
s := make([]int, 10, 0)         // 非法：len(s) > cap(s)
c := make(chan int, 10)         // 缓存大小为10的信道
m := make(map[string]int, 100)  // 初始空间为100个元素的映射

追加与复制切片内建函数 append 与 copy 协助一般的切片操作。对于这两个函数， 无论其内存引用是否与其实参重复，其结果都是独立的。
变参函数 append 追加零个或更多值 x 至 类型为 S 的s，它必须为切片类型，且返回类型为 S 的结果切片， 值 x 被传至类型为 ...T 的形参，其中 T 为 S 的元素类型，且其各自的形参传递规则均适用。 作为一个特例，append 也接受第一个实参可赋予类型 []byte， 且第二个字符串类型的实参后跟 ...。此形式追加字符串类型的字节。
append(s S, x ...T) S  // T是类型为S的元素

若 s 的容量不足够大以适应附加的值，append 会分配一个新的， 足够大的切片以适应现有切片元素与附加的值。因此，返回的切片可能涉及到不同的基本数组。
s0 := []int{0, 0}
s1 := append(s0, 2)                 // 追加单个元素    s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)           // 追加多个元素    s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)             // 追加一个切片    s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)    // 追加重复切片    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")                        t == []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)             // 追加字符串常量  b == []byte{'b', 'a', 'r' }

函数 copy 将切片元素从来源 src 复制到目标 dst 并返回复制的元素数量。两个实参必须都拥有相同的元素类型 T，且必须都可赋予类型为 []T 的切片。 被复制的元素数量为 len(src)与 len(dst) 中最小的那个。 作为一个特例，copy 也接受一个可赋予类型 []byte 的目标实参以及一个字符串类型的来源实参。此形式从该字符串中复制字节到该字节切片。
copy(dst, src []T) int
copy(dst []byte, src string) int

例如：
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")

映射元素的删除内建函数 delete 从映射 m中移除键为 k 的元素。k的类型必须可赋予 m类型的键。
delete(m, k)  // 从映射m中移除元素m[k]

若映射 m 为 nil 或元素 m[k]不存在，则 delete 就是一个空操作。
复数操作三个函数用于组合并分解复数。内建函数 complex 从一个浮点数实部和虚部构造一个复数值。 而 real 和 imag 则提取一个复数值的实部和虚部。
complex(realPart, imaginaryPart floatT) complexT
real(complexT) floatT
imag(complexT) floatT

其实参与返回值的类型一致。对于 complex，两实参必须为相同的浮点类型且其返回类型为 浮点组成部分一致的复数类型：complex64 对应于 float32， complex128 对应于 float64。real与 imag 函数的形式则相反，因此对于一个复数值 z，z == complex(real(z), imag(z))。
若这些函数的操作数均为常量，则返回值亦为常量。
var a = complex(2, -2)             // complex128
var b = complex(1.0, -1.4)         // complex128
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var im = imag(b)                   // float64
var rl = real(c64)                 // float32

恐慌处理内建函数 panic 和 recover 用于协助报告并处理运行时恐慌以及由程序定义的错误情况。
func panic(interface{})
func recover() interface{}

函数 F 中的 panic 调用会终止 F 的执行。 任何被 F 推迟函数都会在 F 返回给其调用者前执行，且不执行该函数剩余的部分。对于其调用者，F 的调用行为自身如同对 panic 的调用，即终止其自身的执行， 并以相同的方式运行被推迟的函数。这会持续到该Go程中所有函数都按相反顺序停止执行之后。 到那时，该程序将被终止，而该错误情况会被报告，包括引发 panic 的实参值。 此终止序列称为恐慌过程。
panic(42)
panic("unreachable")
panic(Error("cannot parse"))

recover 函数允许程序管理恐慌过程Go程的行为。在已推迟函数 （而不是任何被它调用的函数）中，执行 recover 调用会通过恢复正常执行， 并取回传递至 panic 调用的错误值来停止恐慌过程序列。若 recover 在已推迟函数之外被调用，它将不会停止恐慌过程序列。在此情况下，或当Go程不在恐慌过程中时， 或提供给 panic 的实参为 nil 时，recover 就会返回 nil。
func protect(g func()) {
        defer func() {
                log.Println("done")  // 即使有恐慌Println也会正常执行
                if x := recover(); x != nil {
                        log.Printf("run time panic: %v", x)
                }
        }()
        log.Println("start")
        g()
}

下面例子中的 protect 函数调用函数实参 g 并保护由 g 提升的来自运行时恐慌的调用者。
引导当前实现提供了几个在引导过程中有用的内建函数。这些函数因完整性而被保留， 但不保证会继续留在该语言中。它们并不返回结果。
函数       行为

print      打印所有实参；实参的格式取决于具体实现
println    类似print，但会在实参之间打印空格并在末尾打印新行

包Go程序由联系在一起的包构造。包由一个或更多源文件构造转化而来， 源文件与其常量、类型、变量和函数声明一同属于该包，且在相同包的所有文件中它们可互相访问。 这些元素可被导出并用于其它包。
源文件的组织每个源文件都由这些部分构成：首先是一个定义该源文件所属包的包子句， 然后是一个可能为空的声明所需内容所在包的导入声明的集，最后是一个可能为空的函数、 类型、变量与常量声明的集。
源文件 = 包子句 ";" { 导入声明 ";" } { 顶级声明 ";" } .

包子句包子句起始于每个源文件并定义该文件所属的包。
包子句  = "package" 包名 .
包名    = 标识符 .

包名不能为空白标识符.
package math

一个文件集通过共享相同的包名来构成包的实现。实现可能要求包的所有源文件放置在同一目录下。
导入声明导入声明陈述了源文件中所包含的声明，这取决于已导入包的功能 （§程序初始化与执行）， 并使其能够访问该包的可导出标识符。 导入通过命名一个标识符（包名）用于访问，而导入路径则指定可导出的包。
导入声明       = "import" ( 导入指定 | "(" { 导入指定 ";" } ")" ) .
导入指定       = [ "." | 包名 ] 导入路径 .
导入路径       = 字符串字面 .

包名作为限定标识符来访问导入的源文件中包的可导出标识符。 它在文件块中声明。若该包名已省略，则默认由已导入包的包子句中的标识符指定。 若出现一个显式的点号（.）来代替名字， 所有在该包的包块中声明的可导出标识符将在导入源文件的文件块中声明，且无需标识符即可访问。
导入路径的解释取决于具体实现，但它是一个典型的已编译包的完整文件名的子串，且可能是相对于一个已安装包的仓库的。
实现限制：编译器会限制导入路径使用只属于Unicode 中L、M、N、P及S一般类别（不带空格的图形字符）中的非空字符串，且不含字符 !"#$%&'()*,:;<=>?[\]^`{|} 以及Unicode占位字符U+FFFD。
假定我们拥有包含包子句 package math 的已编译包，它导出函数 Sin， 且该包已被安装在标识为"lib/math"的文件中。此表单阐明了在各种类型的导入声明之后， Sin 在导入该包的文件中如何访问。
导入声明                    Sin的本地名

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin

导入声明用来声明导入包与被导入包之间的从属关系。包导入其自身或导入一个不涉及任何可导出标识符的包是非法的。 要为包的副作用（初始化）而单独导入它，需使用空白标识符作为明确的包名：
import _ "lib/math"

一个例子包以下为实现了并发质数筛的完整Go包。
package main

import "fmt"

// 将序列 2, 3, 4, … 发送至信道'ch'。
func generate(ch chan<- int) {
        for i := 2; ; i++ {
                ch <- i  // 将 'i' 发送至信道'ch'。
        }
}

// 将值从信道'src'中复制至信道'dst'，
// 移除可被'prime'整除的数。
func filter(src <-chan int, dst chan<- int, prime int) {
        for i := range src {  // 循环遍历从'src'接收的值。
                if i%prime != 0 {
                        dst <- i  // 将'i'发送至'dst'。
                }
        }
}

// 质数筛：将过滤器串联在一起处理。
func sieve() {
        ch := make(chan int)  // 创建一个新信道。
        go generate(ch)       // 将generate()作为子进程开始。
        for {
                prime := <-ch
                fmt.Print(prime, "\n")
                ch1 := make(chan int)
                go filter(ch, ch1, prime)
                ch = ch1
        }
}

func main() {
        sieve()
}

程序初始化与执行零值当内存为存储值而分配时，不是通过声明就是通过 make 或 new 调用来分配。 而在未提供显式的初始化时，内存将被赋予一个默认的初始化。每个这样的值的元素将置为该类型的零值： 布尔类型为 false，整数类型为 0，浮点数类型为 0.0， 字符串类型为 ""，而指针、函数、接口、切片、信道及映射类型则为 nil。 该初始化递归地完成，例如，对于结构的数组的每一个元素，若没有值被指定，则将其拥有的字段归零。
以下两个简单声明是等价的：
var i int
var i int = 0

在
type T struct { i int; f float64; next *T }
t := new(T)

之后，以下表达式成立：
t.i == 0
t.f == 0.0
t.next == nil

同样，在
var t T

之后，上面的表达式仍然为真。
程序执行没有导入声明的包通过向所有其包级变量赋予初始值，并调用任何在其源中定义的名字和签名为
func init()

的包级函数来初始化。即使在单个源文件中，一个包也可能包含多个 init 函数，它们会按照不确定的顺序执行。
在一个包中，包级变量或常量值会根据数据依赖的顺序初始化或决定：若 A 的初始化器依赖于 B 的值，则A 将在 B 之后设置。若这种依赖形成一个循环， 则会产生一个错误。依赖分析根据词法完成：若 A 的值涉及到 B， 或包含一个初始化器涉及到 B 的值，或递归地涉及一个涉及到 B 的函数，则 A 依赖于 B。若两项并不互相依赖，它们将按照其出现在源里的顺序初始化。 在按包的依赖分析结束后，若 A 的初始化器调用另一个引用了 B 的包中定义的函数，它会产生不确定的结果。
init 函数不能在程序中的任何地方被引用。确切地说，init 既不能被显式地调用， 也不能被指针指向 init 以赋予函数变量。
若一个包拥有导入声明，则被导入的包会在初始化该包自身前初始化。若有多个包导入包 P，则 P 只会初始化一次。
根据构造导入的包可保证在初始化中没有循环依赖。
一个完整的程序通过链接一个单一的、不会被导入的、称为 主包 的，带所有其传递地导入包的包创建。 主包必须拥有包名 main 且声明一个无实参无返回值的函数 main。
func main() { … }

程序通过初始化主包然后调用函数 main 开始执行。当函数 main 返回后，该程序退出。它不会等待其它（非 main）Go程完成。
包初始化—变量初始化与 init 函数的调用—连续地发生在单一的Go程中，一次一包。 一个 init 函数可能在其它Go程中启动，它可以与初始化代码一同运行。然而，初始化总是按顺序执行 init 函数：直到上一个 init 返回后，它才会启动下一个。
错误预声明类型 error 定义为
type error interface {
        Error() string
}

它是表示一种错误状态的传统接口，用 nil 值表示没有错误。 例如，一个从文件中读取数据的函数可被定义为：
func Read(f *File, b []byte) (n int, err error)

运行时恐慌例如试图索引一个越界的数组这类的执行错误会引发运行时恐慌，它等价于 一个定义实现了接口类型 runtime.Error 的值的内建函数 panic 的调用。该类型满足预声明接口类型error。表示明显的运行时错误状态的准确错误值是不确定的。
package runtime

type Error interface {
        error
        // 可能还有其它方法
}

系统考虑包 unsafe编译器已知的内建包 unsafe 为包括违反类型系统操作在内的低级编程提供工具。使用 unsafe 的包为了类型安全必须手动进行审查。该包提供以下接口：
package unsafe

type ArbitraryType int  // 任意Go类型的简写，它并非真正的类型
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uintptr
func Sizeof(variable ArbitraryType) uintptr

任何基本类型为 uintptr 的指针或值均可转换为 Pointer，反之亦然。 ======= Any pointer or value of underlying type uintptr can be converted to a Pointer type and vice versa. >>>>>>> other
<<<<<<< local函数 Alignof 与 Sizeof 接受一个任何类型的表达式 x， 就好像通过 var v = x 声明的变量 v 一样，分别返回其列数或大小。
函数 Offsetof 接受一个表示任何类型结构字段的（可能带括号的）选择者 并返回该字段相对于该结构地址偏移的字节。对于带字段 f 的结构 s ：
uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&s.f))

计算机架构可能需要内存地址 对齐，即，为使变量的地址为因数的倍数，该变量的类型需要对齐。函数 Alignof 接受一个表示任何类型变量的表达式并返回该（类型的）变量对齐的字节。对于变量 x：
uintptr(unsafe.Pointer(&x)) % unsafe.Alignof(x) == 0

调用 Alignof、Offsetof 和 Sizeof 是类型为 uintptr 的编译时常量表达式。
大小与对齐保证对于数值类型（§数值类型），以下大小给予保证：
类型                               字节大小

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16

以下最小对齐属性给予保证：

	1. 对于任何类型的变量 x：unsafe.Alignof(x) 至少为1。
	2. 对于结构类型的变量 x：对于 x 的每一个字段 f， unsafe.Alignof(x) 的值为所有 unsafe.Alignof(x.f) 值中最大的，但至少为1。
	3. 对于数组类型的变量 x：unsafe.Alignof(x) 与 unsafe.Alignof(x[0]) 相同，但至少为1。


若结构或数组类型不包含大小大于零的字段或元素，它们的大小即为零。两个不同的零大小变量在内存中可能有相同的地址。
